<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle-Square Overlap (Normalized)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 5px;
        }
        .control-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            min-width: 150px;
            font-weight: 500;
        }
        input[type="range"] {
            flex: 1;
            max-width: 300px;
        }
        .value-display {
            min-width: 80px;
            font-family: monospace;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .canvas-wrapper {
            flex: 1;
            min-width: 400px;
        }
        canvas {
            border: 2px solid #333;
            display: block;
            background: white;
        }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            font-size: 14px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .info-item {
            padding: 5px;
        }
        .info-label {
            font-weight: 600;
            color: #555;
        }
        .info-value {
            color: #2196F3;
            font-family: monospace;
        }
        .case-indicator {
            font-size: 16px;
            font-weight: bold;
            color: #FF5722;
            padding: 10px;
            background: #FFF3E0;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        h2 {
            margin-top: 0;
            color: #555;
            font-size: 18px;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 5px;
        }
        .note {
            background: #FFF9C4;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 13px;
        }
        .debug {
            background: #E8EAF6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 11px;
            font-family: monospace;
            max-height: 150px;
            overflow-y: auto;
        }
        .polygon-panel {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }
        .polygon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .polygon-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
            background: #fafafa;
            transition: background 0.2s, border-color 0.2s;
        }
        .polygon-item.active {
            border-color: #2196F3;
            background: #E3F2FD;
        }
        .polygon-item .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid #888;
            display: inline-block;
        }
        .polygon-item .remove-btn {
            border: none;
            background: transparent;
            color: #777;
            cursor: pointer;
            font-size: 14px;
        }
        .polygon-item .remove-btn:hover {
            color: #c00;
        }
        .polygon-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
        }
        .polygon-stat-card {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px 10px;
            background: #fafafa;
            font-size: 13px;
        }
        .polygon-stat-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .metric-note {
            font-size: 12px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circle-Shape Overlap Explorer</h1>

        <div class="note">
            <strong>General overlap problem:</strong> Compute the overlap area between a circle of arbitrary radius and various polygon shapes.<br>
            Drag the circle to explore. The app samples the overlap kernel A(cx, cy) = ‚à´1_S ¬∑ 1_C(¬∑‚àí(cx, cy)) (i.e., the convolution of the shape and circle indicators at that offset). The 3D view is this same kernel over a grid of centers.
            <br><br><em>Algorithm:</em> compute segment‚Äìcircle intersections, sum signed triangle areas for edge portions inside the circle, and add circular sector areas for arc portions inside the shape. This boundary-walk pattern generalizes to other polygon/shape overlaps by swapping in their boundary primitives and intersection tests.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="shapeType">Shape Type:</label>
                <select id="shapeType">
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle (Equilateral)</option>
                    <option value="pentagon">Pentagon (Regular)</option>
                    <option value="hexagon">Hexagon (Regular)</option>
                    <option value="octagon">Octagon (Regular)</option>
                    <option value="custom">Custom Polygon</option>
                </select>
            </div>
            <div class="control-group" id="squareControls">
                <label for="squareSize">Square Half-Side:</label>
                <input type="range" id="squareSize" min="0.5" max="3.0" value="1.0" step="0.1">
                <span class="value-display" id="squareSizeValue">1.00</span>
            </div>
            <div class="control-group" id="rectangleControls" style="display:none;">
                <label for="rectWidth">Rectangle Half-Width:</label>
                <input type="range" id="rectWidth" min="0.5" max="3.0" value="1.5" step="0.1">
                <span class="value-display" id="rectWidthValue">1.50</span>
            </div>
            <div class="control-group" id="rectangleHeightControls" style="display:none;">
                <label for="rectHeight">Rectangle Half-Height:</label>
                <input type="range" id="rectHeight" min="0.5" max="3.0" value="1.0" step="0.1">
                <span class="value-display" id="rectHeightValue">1.00</span>
            </div>
            <div class="control-group" id="regularPolyControls" style="display:none;">
                <label for="polyRadius">Polygon Radius:</label>
                <input type="range" id="polyRadius" min="0.5" max="3.0" value="1.0" step="0.1">
                <span class="value-display" id="polyRadiusValue">1.00</span>
            </div>
            <div class="control-group" id="customPolyControls" style="display:none;">
                <label for="customVertices">Vertices (JSON):</label>
                <textarea id="customVertices" rows="3" style="flex: 1; font-family: monospace; font-size: 12px;">[[-1,-1],[1,-1],[1,1],[-1,1]]</textarea>
            </div>
            <div class="control-group">
                <label for="radius">Circle Radius (R):</label>
                <input type="range" id="radius" min="0.1" max="5.0" value="0.5" step="0.05">
                <span class="value-display" id="radiusValue">R = 0.50</span>
            </div>
            <div class="control-group">
                <label for="scale">Display Scale (Zoom):</label>
                <input type="range" id="scale" min="10" max="500" value="200" step="5">
                <span class="value-display" id="scaleValue">200</span>
            </div>
            <div class="control-group">
                <label for="panX">Pan X:</label>
                <input type="range" id="panX" min="-10" max="10" value="0" step="0.1">
                <span class="value-display" id="panXValue">0.00</span>
            </div>
            <div class="control-group">
                <label for="panY">Pan Y:</label>
                <input type="range" id="panY" min="-10" max="10" value="0" step="0.1">
                <span class="value-display" id="panYValue">0.00</span>
            </div>
            <div class="control-group">
                <label for="resolution">3D Resolution:</label>
                <input type="range" id="resolution" min="80" max="240" value="120" step="20">
                <span class="value-display" id="resolutionValue">120</span>
            </div>
            <div class="control-group">
                <label for="autoRotate">3D Auto-Rotate:</label>
                <input type="checkbox" id="autoRotate">
            </div>
            <div class="control-group">
                <label for="showGrid">Show Grid:</label>
                <input type="checkbox" id="showGrid" checked>
            </div>
            <div class="control-group">
                <label for="showRegions">Show Domain Regions:</label>
                <input type="checkbox" id="showRegions" checked>
            </div>
            <div class="control-group">
                <label for="showDebug">Show Debug:</label>
                <input type="checkbox" id="showDebug">
            </div>
            <div class="control-group">
                <label for="boundaryMode">Calculation Mode:</label>
                <select id="boundaryMode">
                    <option value="area">Interior Area</option>
                    <option value="perimeter">Boundary Length (Arc inside polygon)</option>
                </select>
            </div>
            <div class="control-group">
                <button id="drawPolygonBtn" style="padding: 8px 16px; font-size: 14px; cursor: pointer;">
                    üñäÔ∏è Draw Custom Polygon
                </button>
                <span id="drawModeIndicator" style="margin-left: 10px; font-weight: bold; display: none; color: #FF5722;">
                    DRAWING MODE (click to add vertices, double-click to finish)
                </span>
            </div>
            <div class="control-group">
                <button id="animateBtn" style="padding: 8px 16px; font-size: 14px; cursor: pointer; background-color: #FF9800; color: white; border: none; border-radius: 4px;">
                    ‚ñ∂Ô∏è Animate Overlap Calculation
                </button>
                <span id="animationStatus" style="margin-left: 10px; font-weight: bold; display: none; color: #FF9800;">
                    ANIMATING...
                </span>
            </div>
            <div class="control-group polygon-panel">
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Polygon List</strong>
                    <button id="addPolygonBtn" style="padding: 6px 12px; cursor: pointer;">‚ûï Add Polygon</button>
                </div>
                <div class="polygon-list" id="polygonList"></div>
                <div class="metric-note">Use the shape controls to edit the highlighted polygon. Add saves a new polygon with its own color.</div>
            </div>
        </div>

        <div class="case-indicator" id="caseIndicator">Domain: -</div>

        <div class="info">
            <div class="info-grid">
                <div class="info-item">
                    <span class="info-label">Center (cx, cy):</span>
                    <span class="info-value" id="circlePos">(0.00, 0.00)</span>
                </div>
                <div class="info-item">
                    <span class="info-label" id="overlapLabel">Total Overlap Area:</span>
                    <span class="info-value" id="overlapArea">0.000</span>
                </div>
                <div class="info-item">
                    <span class="info-label" id="circleMeasureLabel">Circle Area:</span>
                    <span class="info-value" id="circleArea">0.000</span>
                </div>
                <div class="info-item">
                    <span class="info-label" id="overlapPercentLabel">Overlap %:</span>
                    <span class="info-value" id="overlapPercent">0%</span>
                </div>
            </div>
        </div>
        <div class="info" id="polygonStatsContainer" style="display:none;">
            <h2 style="margin-top:0;">Per-Polygon Metrics</h2>
            <div id="polygonStats" class="polygon-stats"></div>
        </div>

        <div class="debug" id="debugInfo" style="display:none;"></div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h2>Interactive 2D View (Drag circle)</h2>
                <canvas id="canvas2d" width="600" height="600"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h2>3D Surface Plot (Overlap vs position)</h2>
                <canvas id="canvas3d" width="600" height="600"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        /**
         * CIRCLE-POLYGON OVERLAP VISUALIZER
         *
         * This webapp computes and visualizes the overlap area between a circle and
         * arbitrary polygons using a boundary-walk algorithm based on Green's theorem.
         *
         * MATHEMATICAL FRAMEWORK:
         * ========================
         *
         * The overlap area is computed as the integral of the winding number function:
         *     A = ‚à´‚à´_‚Ñù¬≤ w(‚àÇR, p) dp
         *
         * where w(‚àÇR, p) is the winding number of the boundary ‚àÇR around point p.
         *
         * Green's theorem converts this to a boundary integral:
         *     A = (1/2) ‚àÆ_‚àÇR (x dy - y dx)
         *
         * For circle-polygon overlap, the boundary consists of:
         *   1. Polygon edges inside the circle ‚Üí signed triangles from circle center
         *   2. Circle arcs inside the polygon ‚Üí circular sectors
         *
         * This is a generalization of the shoelace formula for mixed straight/curved boundaries.
         *
         * KEY CONCEPTS:
         * =============
         *
         * 1. WINDING NUMBER PERSPECTIVE:
         *    - Points inside overlap have winding number w = 1
         *    - Points outside have w = 0
         *    - Self-intersecting polygons can have w > 1 (counted multiple times)
         *    - Multiple overlapping polygons: winding numbers add
         *
         * 2. SIGNED AREA DECOMPOSITION:
         *    - Triangles: (1/2)(x‚ÇÅy‚ÇÇ - x‚ÇÇy‚ÇÅ) = (1/2) Im(zÃÑ‚ÇÅ¬∑z‚ÇÇ) in complex notation
         *    - Sectors: (1/2)r¬≤ŒîŒ∏ for arc from angle Œ∏‚ÇÅ to Œ∏‚ÇÇ
         *    - Orientation: counterclockwise = positive, clockwise = negative
         *
         * 3. LINE REFERENCE VS POINT REFERENCE:
         *    - Shoelace formula: trapezoids from coordinate axes (line reference)
         *    - Circle overlap: triangles from circle center (point reference)
         *    - Both valid by Green's theorem, different geometric decompositions
         *
         * 4. CONVOLUTION INTERPRETATION:
         *    The overlap function A(cx, cy) is a convolution:
         *        A(cx, cy) = (1_P ‚ãÜ 1_C)(cx, cy)
         *    where 1_P and 1_C are indicator functions.
         *
         *    The 3D surface plot visualizes this convolution kernel.
         *
         * IMPLEMENTATION HIGHLIGHTS:
         * ==========================
         *
         * - Exact geometric tests (not sampling) for numerical stability
         * - Handles convex and non-convex polygons
         * - Supports multi-polygon mode with independent overlaps
         * - Boundary mode: computes arc length instead of area
         * - Animation mode: visualizes triangle/sector accumulation
         * - 3D surface plot: overlap area as function of circle center position
         *
         * See overlapByBoundary() for the core algorithm implementation.
         */
        const CANVAS_CENTER = 300;
        const SQUARE_HALF_SIDE = 1.0;  // Legacy constant, now configurable

        class CircleSquareOverlap {
            constructor() {
                this.canvas2d = document.getElementById('canvas2d');
                this.ctx = this.canvas2d.getContext('2d');
                this.canvas3d = document.getElementById('canvas3d');

                this.R = 0.5;  // Circle radius (now arbitrary)
                this.scale = 200;  // pixels per unit
                this.panX = 0;  // Pan offset X
                this.panY = 0;  // Pan offset Y
                this.cx = 0;  // Circle center x
                this.cy = 0;  // Circle center y

                this.isDragging = false;
                this.isDrawingPolygon = false;
                this.polygonVertices = [];
                this.resolution = 120;
                this.currentCase = '';
                this.debugText = '';
                this.colorPalette = ['#4CAF50', '#2196F3', '#FF5722', '#9C27B0', '#009688', '#795548', '#3F51B5', '#8BC34A'];
                this.polygons = [];
                this.activePolygonIndex = 0;

                // Animation state
                this.isAnimating = false;
                this.animationComponents = [];
                this.animationStep = 0;
                this.animationTimerId = null;
                this.wasAnimatingBeforeDrag = false;
                this.wasAnimatingBeforeParamChange = false;
                this.restartAnimationTimer = null;

                // Shape properties
                this.shapeType = 'square';
                this.squareSize = 1.0;
                this.rectWidth = 1.5;
                this.rectHeight = 1.0;
                this.polyRadius = 1.0;
                this.customVertices = [[-1,-1],[1,-1],[1,1],[-1,1]];
                this.shapeVertices = [];

                // Calculation mode: 'area' for interior overlap, 'perimeter' for arc length inside polygon
                this.boundaryMode = 'area';

                this.updateShapeVertices();
                this.initializePolygonList();
                this.setupControls();
                this.updateShapeControls();  // Initialize control visibility
                this.setup2DCanvas();
                this.setup3DCanvas();
                this.updateDisplay();
            }

            pauseAnimationForParamChange() {
                if (this.restartAnimationTimer) {
                    clearTimeout(this.restartAnimationTimer);
                    this.restartAnimationTimer = null;
                }
                if (this.isAnimating) {
                    this.wasAnimatingBeforeParamChange = true;
                    this.stopAnimation();
                }
            }

            scheduleAnimationRestart() {
                if (!this.wasAnimatingBeforeParamChange) return;
                if (this.restartAnimationTimer) {
                    clearTimeout(this.restartAnimationTimer);
                }
                this.restartAnimationTimer = setTimeout(() => {
                    this.restartAnimationTimer = null;
                    if (this.wasAnimatingBeforeParamChange) {
                        this.wasAnimatingBeforeParamChange = false;
                        this.startAnimation();
                    }
                }, 400);
            }

            setupControls() {
                // Shape selector
                document.getElementById('shapeType').addEventListener('change', (e) => {
                    this.pauseAnimationForParamChange();
                    this.shapeType = e.target.value;
                    this.updateShapeControls();
                    this.updateShapeVertices();
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                // Square controls
                document.getElementById('squareSize').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.squareSize = parseFloat(e.target.value);
                    document.getElementById('squareSizeValue').textContent = this.squareSize.toFixed(2);
                    this.updateShapeVertices();
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                // Rectangle controls
                document.getElementById('rectWidth').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.rectWidth = parseFloat(e.target.value);
                    document.getElementById('rectWidthValue').textContent = this.rectWidth.toFixed(2);
                    this.updateShapeVertices();
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('rectHeight').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.rectHeight = parseFloat(e.target.value);
                    document.getElementById('rectHeightValue').textContent = this.rectHeight.toFixed(2);
                    this.updateShapeVertices();
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                // Regular polygon controls
                document.getElementById('polyRadius').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.polyRadius = parseFloat(e.target.value);
                    document.getElementById('polyRadiusValue').textContent = this.polyRadius.toFixed(2);
                    this.updateShapeVertices();
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                // Custom vertices
                document.getElementById('customVertices').addEventListener('input', (e) => {
                    try {
                        this.pauseAnimationForParamChange();
                        this.customVertices = JSON.parse(e.target.value);
                        this.updateShapeVertices();
                        this.updateDisplay();
                        this.update3DSurface();
                        this.scheduleAnimationRestart();
                    } catch (err) {
                        console.error('Invalid JSON for vertices:', err);
                    }
                });

                document.getElementById('radius').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.R = parseFloat(e.target.value);
                    document.getElementById('radiusValue').textContent = `R = ${this.R.toFixed(2)}`;
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('scale').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = this.scale;
                    this.updateDisplay();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('panX').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.panX = parseFloat(e.target.value);
                    document.getElementById('panXValue').textContent = this.panX.toFixed(2);
                    this.updateDisplay();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('panY').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.panY = parseFloat(e.target.value);
                    document.getElementById('panYValue').textContent = this.panY.toFixed(2);
                    this.updateDisplay();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('resolution').addEventListener('input', (e) => {
                    this.pauseAnimationForParamChange();
                    this.resolution = parseInt(e.target.value);
                    document.getElementById('resolutionValue').textContent = this.resolution;
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('showGrid').addEventListener('change', () => {
                    this.updateDisplay();
                });

                document.getElementById('showRegions').addEventListener('change', () => {
                    this.updateDisplay();
                });

                document.getElementById('showDebug').addEventListener('change', (e) => {
                    document.getElementById('debugInfo').style.display = e.target.checked ? 'block' : 'none';
                });

                // Boundary mode selector
                document.getElementById('boundaryMode').addEventListener('change', (e) => {
                    this.pauseAnimationForParamChange();
                    this.boundaryMode = e.target.value;
                    this.updateDisplay();
                    this.update3DSurface();
                    this.scheduleAnimationRestart();
                });

                document.getElementById('autoRotate').addEventListener('change', (e) => {
                    if (this.controls) {
                        this.controls.autoRotate = e.target.checked;
                    }
                });

                // Draw polygon button
                document.getElementById('drawPolygonBtn').addEventListener('click', () => {
                    this.pauseAnimationForParamChange();
                    this.isDrawingPolygon = !this.isDrawingPolygon;
                    if (this.isDrawingPolygon) {
                        this.polygonVertices = [];
                        this.shapeType = 'custom';
                        document.getElementById('shapeType').value = 'custom';
                        this.updateShapeControls();
                        document.getElementById('drawModeIndicator').style.display = 'inline';
                        document.getElementById('drawPolygonBtn').textContent = '‚úñÔ∏è Cancel Drawing';
                    } else {
                        document.getElementById('drawModeIndicator').style.display = 'none';
                        document.getElementById('drawPolygonBtn').textContent = 'üñäÔ∏è Draw Custom Polygon';
                        if (this.polygonVertices.length >= 3) {
                            this.finishPolygonDrawing();
                        }
                    }
                    this.updateDisplay();
                    this.scheduleAnimationRestart();
                });

                // Polygon list actions
                document.getElementById('addPolygonBtn').addEventListener('click', () => {
                    this.pauseAnimationForParamChange();
                    this.addPolygonFromCurrent();
                });

                // Animation button
                document.getElementById('animateBtn').addEventListener('click', () => {
                    if (this.isAnimating) {
                        this.stopAnimation();
                    } else {
                        this.startAnimation();
                    }
                });
            }

            updateShapeControls() {
                // Hide all shape-specific controls
                document.getElementById('squareControls').style.display = 'none';
                document.getElementById('rectangleControls').style.display = 'none';
                document.getElementById('rectangleHeightControls').style.display = 'none';
                document.getElementById('regularPolyControls').style.display = 'none';
                document.getElementById('customPolyControls').style.display = 'none';

                // Show relevant controls
                switch(this.shapeType) {
                    case 'square':
                        document.getElementById('squareControls').style.display = 'flex';
                        break;
                    case 'rectangle':
                        document.getElementById('rectangleControls').style.display = 'flex';
                        document.getElementById('rectangleHeightControls').style.display = 'flex';
                        break;
                    case 'triangle':
                    case 'pentagon':
                    case 'hexagon':
                    case 'octagon':
                        document.getElementById('regularPolyControls').style.display = 'flex';
                        break;
                    case 'custom':
                        document.getElementById('customPolyControls').style.display = 'flex';
                        break;
                }
            }

            updateShapeVertices() {
                switch(this.shapeType) {
                    case 'square': {
                        const s = this.squareSize;
                        this.shapeVertices = [
                            { x: -s, y: -s },
                            { x: s, y: -s },
                            { x: s, y: s },
                            { x: -s, y: s }
                        ];
                        break;
                    }
                    case 'rectangle': {
                        const w = this.rectWidth;
                        const h = this.rectHeight;
                        this.shapeVertices = [
                            { x: -w, y: -h },
                            { x: w, y: -h },
                            { x: w, y: h },
                            { x: -w, y: h }
                        ];
                        break;
                    }
                    case 'triangle': {
                        const r = this.polyRadius;
                        this.shapeVertices = [];
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * 2 * Math.PI / 3) - Math.PI / 2;
                            this.shapeVertices.push({
                                x: r * Math.cos(angle),
                                y: r * Math.sin(angle)
                            });
                        }
                        break;
                    }
                    case 'pentagon': {
                        const r = this.polyRadius;
                        this.shapeVertices = [];
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                            this.shapeVertices.push({
                                x: r * Math.cos(angle),
                                y: r * Math.sin(angle)
                            });
                        }
                        break;
                    }
                    case 'hexagon': {
                        const r = this.polyRadius;
                        this.shapeVertices = [];
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 2 * Math.PI / 6) - Math.PI / 2;
                            this.shapeVertices.push({
                                x: r * Math.cos(angle),
                                y: r * Math.sin(angle)
                            });
                        }
                        break;
                    }
                    case 'octagon': {
                        const r = this.polyRadius;
                        this.shapeVertices = [];
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * 2 * Math.PI / 8) - Math.PI / 2;
                            this.shapeVertices.push({
                                x: r * Math.cos(angle),
                                y: r * Math.sin(angle)
                            });
                        }
                        break;
                    }
                    case 'custom': {
                        this.shapeVertices = this.customVertices.map(v => ({ x: v[0], y: v[1] }));
                        break;
                    }
                }

                // Enforce consistent counter-clockwise orientation for positive signed areas
                this.ensureCounterClockwise();
                this.updateActivePolygonRecord();
            }

            polygonSignedArea(vertices) {
                let acc = 0;
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    acc += vertices[i].x * vertices[j].y - vertices[i].y * vertices[j].x;
                }
                return 0.5 * acc;
            }

            ensureCounterClockwise() {
                if (this.shapeVertices.length < 3) return;
                if (this.polygonSignedArea(this.shapeVertices) < 0) {
                    this.shapeVertices.reverse();
                }
            }

            colorWithAlpha(color, alpha) {
                if (color && color.startsWith('#') && color.length === 7) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                return color;
            }

            initializePolygonList() {
                const initial = this.buildPolygonState('Polygon 1', this.colorPalette[0]);
                this.polygons.push(initial);
                this.activePolygonIndex = 0;
                this.renderPolygonList();
            }

            buildPolygonState(name, color) {
                return {
                    id: Date.now() + Math.random(),
                    name,
                    color,
                    shapeType: this.shapeType,
                    squareSize: this.squareSize,
                    rectWidth: this.rectWidth,
                    rectHeight: this.rectHeight,
                    polyRadius: this.polyRadius,
                    customVertices: JSON.parse(JSON.stringify(this.customVertices)),
                    vertices: this.shapeVertices.map(v => ({ x: v.x, y: v.y }))
                };
            }

            renderPolygonList() {
                const list = document.getElementById('polygonList');
                if (!list) return;
                list.innerHTML = '';

                this.polygons.forEach((poly, idx) => {
                    const item = document.createElement('div');
                    item.className = `polygon-item ${idx === this.activePolygonIndex ? 'active' : ''}`;

                    const colorDot = document.createElement('span');
                    colorDot.className = 'color-dot';
                    colorDot.style.background = poly.color;

                    const label = document.createElement('span');
                    label.textContent = `${poly.name} (${poly.shapeType})`;

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = '‚úñ';
                    removeBtn.title = 'Remove polygon';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removePolygon(idx);
                    });

                    item.appendChild(colorDot);
                    item.appendChild(label);
                    if (this.polygons.length > 1) {
                        item.appendChild(removeBtn);
                    }
                    item.addEventListener('click', () => this.setActivePolygon(idx));

                    list.appendChild(item);
                });
            }

            setActivePolygon(index) {
                if (index < 0 || index >= this.polygons.length) return;
                this.pauseAnimationForParamChange();
                this.activePolygonIndex = index;
                const poly = this.polygons[index];

                // Sync controls to polygon params
                this.shapeType = poly.shapeType;
                this.squareSize = poly.squareSize;
                this.rectWidth = poly.rectWidth;
                this.rectHeight = poly.rectHeight;
                this.polyRadius = poly.polyRadius;
                this.customVertices = JSON.parse(JSON.stringify(poly.customVertices));
                this.shapeVertices = poly.vertices.map(v => ({ x: v.x, y: v.y }));

                // Update control UI values
                document.getElementById('shapeType').value = this.shapeType;
                document.getElementById('squareSize').value = this.squareSize;
                document.getElementById('squareSizeValue').textContent = this.squareSize.toFixed(2);
                document.getElementById('rectWidth').value = this.rectWidth;
                document.getElementById('rectWidthValue').textContent = this.rectWidth.toFixed(2);
                document.getElementById('rectHeight').value = this.rectHeight;
                document.getElementById('rectHeightValue').textContent = this.rectHeight.toFixed(2);
                document.getElementById('polyRadius').value = this.polyRadius;
                document.getElementById('polyRadiusValue').textContent = this.polyRadius.toFixed(2);
                document.getElementById('customVertices').value = JSON.stringify(this.customVertices);

                this.updateShapeControls();
                this.updateDisplay();
                this.update3DSurface();
                this.renderPolygonList();
                this.scheduleAnimationRestart();
            }

            addPolygonFromCurrent() {
                const name = `Polygon ${this.polygons.length + 1}`;
                const color = this.colorPalette[this.polygons.length % this.colorPalette.length];
                const newPoly = this.buildPolygonState(name, color);
                this.polygons.push(newPoly);
                this.setActivePolygon(this.polygons.length - 1);
                this.renderPolygonList();
            }

            removePolygon(index) {
                if (this.polygons.length <= 1) return;
                this.polygons.splice(index, 1);
                if (this.activePolygonIndex >= this.polygons.length) {
                    this.activePolygonIndex = this.polygons.length - 1;
                }
                const active = this.polygons[this.activePolygonIndex];
                // Re-sync to active polygon after removal
                this.shapeType = active.shapeType;
                this.squareSize = active.squareSize;
                this.rectWidth = active.rectWidth;
                this.rectHeight = active.rectHeight;
                this.polyRadius = active.polyRadius;
                this.customVertices = JSON.parse(JSON.stringify(active.customVertices));
                this.shapeVertices = active.vertices.map(v => ({ x: v.x, y: v.y }));
                this.renderPolygonList();
                this.updateShapeControls();
                this.updateDisplay();
                this.update3DSurface();
                this.scheduleAnimationRestart();
            }

            updateActivePolygonRecord() {
                if (!this.polygons[this.activePolygonIndex]) return;
                const poly = this.polygons[this.activePolygonIndex];
                poly.shapeType = this.shapeType;
                poly.squareSize = this.squareSize;
                poly.rectWidth = this.rectWidth;
                poly.rectHeight = this.rectHeight;
                poly.polyRadius = this.polyRadius;
                poly.customVertices = JSON.parse(JSON.stringify(this.customVertices));
                poly.vertices = this.shapeVertices.map(v => ({ x: v.x, y: v.y }));
                this.renderPolygonList();
            }

            finishPolygonDrawing() {
                this.pauseAnimationForParamChange();
                if (this.polygonVertices.length >= 3) {
                    this.customVertices = this.polygonVertices;
                    document.getElementById('customVertices').value = JSON.stringify(this.customVertices);
                    // Switch to custom polygon mode
                    this.shapeType = 'custom';
                    document.getElementById('shapeType').value = 'custom';
                    this.updateShapeControls();
                    this.updateShapeVertices();
                }
                this.isDrawingPolygon = false;
                this.polygonVertices = [];
                document.getElementById('drawModeIndicator').style.display = 'none';
                document.getElementById('drawPolygonBtn').textContent = 'üñäÔ∏è Draw Custom Polygon';
                this.updateDisplay();
                this.update3DSurface();
                this.scheduleAnimationRestart();
            }

            pixelToWorld(px, py) {
                return {
                    x: (px - CANVAS_CENTER) / this.scale + this.panX,
                    y: (CANVAS_CENTER - py) / this.scale + this.panY
                };
            }

            worldToPixel(wx, wy) {
                return {
                    x: CANVAS_CENTER + (wx - this.panX) * this.scale,
                    y: CANVAS_CENTER - (wy - this.panY) * this.scale
                };
            }

            setup2DCanvas() {
                this.canvas2d.addEventListener('mousedown', (e) => {
                    const rect = this.canvas2d.getBoundingClientRect();
                    const px = e.clientX - rect.left;
                    const py = e.clientY - rect.top;
                    const world = this.pixelToWorld(px, py);

                    // Handle polygon drawing mode
                    if (this.isDrawingPolygon) {
                        this.polygonVertices.push([world.x, world.y]);
                        this.updateDisplay();
                        return;
                    }

                    // Handle circle dragging mode
                    const dx = world.x - this.cx;
                    const dy = world.y - this.cy;
                    if (dx * dx + dy * dy <= this.R * this.R) {
                        this.isDragging = true;

                        // Stop animation during drag
                        if (this.isAnimating) {
                            this.wasAnimatingBeforeDrag = true;
                            this.stopAnimation();
                        }
                    }
                });

                // Double-click to finish polygon drawing
                this.canvas2d.addEventListener('dblclick', (e) => {
                    if (this.isDrawingPolygon && this.polygonVertices.length >= 3) {
                        e.preventDefault();
                        this.finishPolygonDrawing();
                    }
                });

                this.canvas2d.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const rect = this.canvas2d.getBoundingClientRect();
                        const px = e.clientX - rect.left;
                        const py = e.clientY - rect.top;
                        const world = this.pixelToWorld(px, py);
                        this.cx = world.x;
                        this.cy = world.y;
                        this.updateDisplay();
                    }
                });

                this.canvas2d.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        // Restart animation if it was running before drag
                        if (this.wasAnimatingBeforeDrag) {
                            this.wasAnimatingBeforeDrag = false;
                            this.startAnimation();
                        }
                    }
                });

                this.canvas2d.addEventListener('mouseleave', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        // Restart animation if it was running before drag
                        if (this.wasAnimatingBeforeDrag) {
                            this.wasAnimatingBeforeDrag = false;
                            this.startAnimation();
                        }
                    }
                });

                // Mouse wheel zoom
                this.canvas2d.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.pauseAnimationForParamChange();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.max(10, Math.min(500, this.scale * zoomFactor));

                    // Get mouse position before zoom
                    const rect = this.canvas2d.getBoundingClientRect();
                    const px = e.clientX - rect.left;
                    const py = e.clientY - rect.top;
                    const worldBefore = this.pixelToWorld(px, py);

                    // Update scale
                    this.scale = newScale;
                    document.getElementById('scale').value = newScale;
                    document.getElementById('scaleValue').textContent = newScale.toFixed(0);

                    // Adjust pan to zoom towards mouse position
                    const worldAfter = this.pixelToWorld(px, py);
                    this.panX += worldBefore.x - worldAfter.x;
                    this.panY += worldBefore.y - worldAfter.y;
                    document.getElementById('panX').value = this.panX;
                    document.getElementById('panXValue').textContent = this.panX.toFixed(2);
                    document.getElementById('panY').value = this.panY;
                    document.getElementById('panYValue').textContent = this.panY.toFixed(2);

                    this.updateDisplay();
                    this.scheduleAnimationRestart();
                });
            }

            setup3DCanvas() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                this.camera = new THREE.PerspectiveCamera(
                    50,
                    this.canvas3d.width / this.canvas3d.height,
                    0.1,
                    20
                );
                this.camera.position.set(3, 3, 3);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas3d,
                    antialias: true
                });
                this.renderer.setSize(this.canvas3d.width, this.canvas3d.height);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                const axesHelper = new THREE.AxesHelper(1.5);
                this.scene.add(axesHelper);

                // Add OrbitControls for interactive 3D rotation
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 2;
                this.controls.maxDistance = 10;
                this.controls.maxPolarAngle = Math.PI / 2 + 0.5;
                this.controls.autoRotate = false;
                this.controls.autoRotateSpeed = 0.5;

                this.update3DSurface();
                this.animate3D();
            }

            // Haskell formulas - direct translation
            segmentArea(r, sagitta) {
                if (sagitta <= 0 || sagitta > 2 * r) return 0;
                const s = sagitta;
                return r * r * Math.acos(1 - s / r) - (r - s) * Math.sqrt(r * r - (r - s) * (r - s));
            }

            circleArea(r) {
                return Math.PI * r * r;
            }

            // Now: (x, y) are the sagitta values, not coordinates!
            caseBOverlapArea(r, sagitta_y) {
                return this.circleArea(r) - this.segmentArea(r, sagitta_y);
            }

            caseCOverlapArea(r, sagitta_x, sagitta_y) {
                return this.circleArea(r) - this.segmentArea(r, sagitta_x) - this.segmentArea(r, sagitta_y);
            }

            cornerSectorArea(r, cx, cy, signHoriz, signVert) {
                const s = SQUARE_HALF_SIDE;
                const dx = s - cx; // vector from center to corner
                const dy = s - cy;

                // Corner must be inside circle
                if (dx * dx + dy * dy > r * r) return 0;

                const vertDelta = r * r - dx * dx;
                const horizDelta = r * r - dy * dy;
                if (vertDelta < 0 || horizDelta < 0) return 0;

                const vertOffset = Math.sqrt(vertDelta);
                const horizOffset = Math.sqrt(horizDelta);

                const pickOnEdge = (centerCoord, offset, towardCorner) => {
                    const candidates = [centerCoord + offset, centerCoord - offset];
                    const inSquare = candidates.filter((v) => Math.abs(v) <= s + 1e-9);
                    if (inSquare.length === 0) return null;
                    return towardCorner >= 0 ? Math.max(...inSquare) : Math.min(...inSquare);
                };

                const yOnVertical = pickOnEdge(cy, vertOffset, dy);
                const xOnHorizontal = pickOnEdge(cx, horizOffset, dx);
                if (yOnVertical === null || xOnHorizontal === null) return 0;

                const cornerVec = { x: dx, y: dy };
                const vertVec = { x: s - cx, y: yOnVertical - cy };    // along vertical edge x = s
                const horizVec = { x: xOnHorizontal - cx, y: s - cy }; // along horizontal edge y = s

                const lenH2 = horizVec.x * horizVec.x + horizVec.y * horizVec.y;
                const lenV2 = vertVec.x * vertVec.x + vertVec.y * vertVec.y;
                const lenC2 = cornerVec.x * cornerVec.x + cornerVec.y * cornerVec.y;

                const dotHV = horizVec.x * vertVec.x + horizVec.y * vertVec.y;
                const dotCH = cornerVec.x * horizVec.x + cornerVec.y * horizVec.y;
                const dotCV = cornerVec.x * vertVec.x + cornerVec.y * vertVec.y;

                const crossMagHV = Math.sqrt(lenH2 * lenV2 - dotHV * dotHV);
                const sectorTheta = Math.atan2(crossMagHV, dotHV);
                const sectorArea = 0.5 * r * r * sectorTheta;

                const triangleHoriz = 0.5 * Math.sqrt(lenC2 * lenH2 - dotCH * dotCH);
                const triangleVert = 0.5 * Math.sqrt(lenC2 * lenV2 - dotCV * dotCV);

                return sectorArea + signHoriz * triangleHoriz + signVert * triangleVert;
            }

            caseDOverlapArea(r, cx, cy) {
                // Case D: corner inside circle.
                // This case covers all situations where a corner is inside the circle,
                // regardless of whether the center is inside or outside the square.
                // The cornerSectorArea function handles the different sign combinations internally.
                return this.cornerSectorArea(r, cx, cy, +1, +1);
            }

            caseEOverlapArea(r, sagitta_y) {
                return this.segmentArea(r, sagitta_y);
            }

            caseFOverlapArea(r, cx, cy) {
                // Legacy: Case F is now merged with Case D.
                // This handles mixed position (center outside one axis, inside the other).
                const s = SQUARE_HALF_SIDE;
                const dx = s - cx;
                const dy = s - cy;

                // Outside +x only (inside vertically)
                if (dx < 0 && dy >= 0) {
                    return this.cornerSectorArea(r, cx, cy, +1, -1); // keep horizontal, subtract vertical
                }

                // Outside +y only (inside horizontally)
                if (dy < 0 && dx >= 0) {
                    return this.cornerSectorArea(r, cx, cy, -1, +1); // subtract horizontal, keep vertical
                }

                return 0;
            }

            caseGOverlapArea(r, cx, cy) {
                // Legacy: Case G is now merged with Case D.
                // This handles center outside both axes.
                const s = SQUARE_HALF_SIDE;
                const dx = s - cx;
                const dy = s - cy;

                if (dx < 0 && dy < 0) {
                    return this.cornerSectorArea(r, cx, cy, -1, -1);
                }
                return 0;
            }

            // Check if a point is inside the polygon using ray casting algorithm
            pointInPolygon(x, y, verts = this.shapeVertices) {
                const vertices = verts || [];
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;

                    const intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            circleSegmentIntersections(p1, p2, r) {
                // Return intersections with circle at origin, along segment p1->p2, as {t, x, y}
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const a = dx * dx + dy * dy;
                const b = 2 * (p1.x * dx + p1.y * dy);
                const c = p1.x * p1.x + p1.y * p1.y - r * r;
                const disc = b * b - 4 * a * c;
                if (disc < 0) return [];
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-b - sqrtDisc) / (2 * a);
                const t2 = (-b + sqrtDisc) / (2 * a);
                const hits = [];
                if (t1 >= 0 && t1 <= 1) hits.push({ t: t1, x: p1.x + t1 * dx, y: p1.y + t1 * dy });
                if (t2 >= 0 && t2 <= 1 && disc > 0) hits.push({ t: t2, x: p1.x + t2 * dx, y: p1.y + t2 * dy });
                return hits.sort((a, b) => a.t - b.t);
            }

            // Compute minimum distance from point (px, py) to line segment from v1 to v2
            distanceToSegment(px, py, v1, v2) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const lengthSquared = dx * dx + dy * dy;

                if (lengthSquared === 0) {
                    // Degenerate segment (v1 == v2)
                    const dpx = px - v1.x;
                    const dpy = py - v1.y;
                    return Math.sqrt(dpx * dpx + dpy * dpy);
                }

                // Project point onto line, clamped to segment
                const t = Math.max(0, Math.min(1, ((px - v1.x) * dx + (py - v1.y) * dy) / lengthSquared));
                const projX = v1.x + t * dx;
                const projY = v1.y + t * dy;
                const distX = px - projX;
                const distY = py - projY;
                return Math.sqrt(distX * distX + distY * distY);
            }

            /**
             * Boundary-walk algorithm for circle-polygon overlap
             *
             * MATHEMATICAL FOUNDATION:
             * This algorithm computes the overlap area by walking the boundary of the
             * intersection region and applying Green's theorem. The signed area equals
             * the integral of the winding number function over the plane:
             *
             *     A = ‚à´‚à´_‚Ñù¬≤ w(‚àÇR, p) dp
             *
             * where w(‚àÇR, p) is the winding number of the boundary around point p.
             *
             * Green's theorem converts this to a boundary integral:
             *     A = (1/2) ‚àÆ_‚àÇR (x dy - y dx)
             *
             * For the overlap region, the boundary ‚àÇR consists of:
             *   1. Polygon edges inside the circle (contribute triangles from center)
             *   2. Circle arcs inside the polygon (contribute circular sectors)
             *
             * DECOMPOSITION:
             *   - Triangles: Each polygon edge segment inside the circle contributes
             *     a signed triangle area from the circle center (cx, cy) to the segment
             *     endpoints. This is the cross-product: (1/2)(x‚ÇÅy‚ÇÇ - x‚ÇÇy‚ÇÅ)
             *
             *   - Sectors: Each circle arc between consecutive intersection points that
             *     lies inside the polygon contributes a circular sector area: (1/2)r¬≤ŒîŒ∏
             *
             * The winding number interpretation:
             *   - Inside overlap: w = 1 ‚Üí contributes area
             *   - Outside overlap: w = 0 ‚Üí contributes nothing
             *   - Boundary orientation determines sign (counterclockwise = positive)
             *
             * This naturally handles:
             *   - Self-intersecting polygons (winding number > 1 in overlapping regions)
             *   - Multiple polygons (winding numbers add)
             *   - Complex boundary configurations
             *
             * @param {number} cx - Circle center x-coordinate
             * @param {number} cy - Circle center y-coordinate
             * @param {number} r - Circle radius
             * @param {boolean} collectData - Whether to collect triangle/sector data for visualization
             * @param {Array} verts - Polygon vertices
             * @returns {number|Object} Area (or arc length in boundary mode), or object with decomposition
             */
            overlapByBoundary(cx, cy, r, collectData = false, verts = this.shapeVertices) {
                const shapeVerts = verts || [];
                const isBoundaryMode = this.boundaryMode === 'perimeter';

                const circlePts = [];
                let measure = 0;  // area or arc length depending on mode
                const triangles = [];
                const sectors = [];

                // STEP 1: Walk polygon edges and accumulate triangular contributions
                // Each edge inside the circle contributes signed area via the shoelace formula
                // This corresponds to integrating x dy along straight boundary segments
                for (let i = 0; i < shapeVerts.length; i++) {
                    const v1 = shapeVerts[i];
                    const v2 = shapeVerts[(i + 1) % shapeVerts.length];
                    // Translate to circle-centered coordinates
                    const p1 = { x: v1.x - cx, y: v1.y - cy };
                    const p2 = { x: v2.x - cx, y: v2.y - cy };

                    // Find where this edge intersects the circle boundary
                    const intersections = this.circleSegmentIntersections(p1, p2, r);
                    if (intersections.length > 0) {
                        intersections.forEach((hit) => {
                            circlePts.push({
                                x: hit.x + cx,
                                y: hit.y + cy,
                                edgeIndex: i,
                                edgeParam: hit.t  // Position along edge (0 to 1)
                            });
                        });
                    }

                    // Split edge into segments: between vertices and intersections
                    // Only segments with midpoint inside the circle contribute
                    const candidates = [{ t: 0, x: p1.x, y: p1.y }, ...intersections, { t: 1, x: p2.x, y: p2.y }];
                    for (let j = 0; j < candidates.length - 1; j++) {
                        const a = candidates[j];
                        const b = candidates[j + 1];
                        const mid = { x: 0.5 * (a.x + b.x), y: 0.5 * (a.y + b.y) };
                        const midInside = mid.x * mid.x + mid.y * mid.y <= r * r;
                        if (midInside) {
                            // Triangle from circle center to edge segment
                            // Signed area = (1/2) cross product in circle-centered coordinates
                            // This is the shoelace formula: (1/2)(x‚ÇÅy‚ÇÇ - x‚ÇÇy‚ÇÅ)
                            // Equivalently: (1/2) Im(zÃÑ‚ÇÅ ¬∑ z‚ÇÇ) in complex notation
                            if (!isBoundaryMode) {
                                const triangleArea = 0.5 * (a.x * b.y - a.y * b.x);
                                measure += triangleArea;
                                if (collectData) {
                                    triangles.push({
                                        p1: { x: cx, y: cy },
                                        p2: { x: a.x + cx, y: a.y + cy },
                                        p3: { x: b.x + cx, y: b.y + cy },
                                        value: triangleArea,
                                        edgeIndex: i,
                                        edgeParam: a.t,      // Start position
                                        edgeParamEnd: b.t    // End position
                                    });
                                }
                            }
                        }
                    }
                }

                // Special case: polygon fully inside circle (no intersections, triangles already cover it)
                const allVertsInside = shapeVerts.every((v) => {
                    const dx = v.x - cx;
                    const dy = v.y - cy;
                    return dx * dx + dy * dy <= r * r + 1e-9;
                });
                if (allVertsInside && circlePts.length === 0) {
                    if (collectData) {
                        return { value: isBoundaryMode ? 0 : measure, triangles: isBoundaryMode ? [] : triangles, sectors: [] };
                    }
                    return isBoundaryMode ? 0 : measure;
                }

                // Special case: no overlap
                // Exact test: center outside polygon AND all vertices farther than radius from center
                if (!this.pointInPolygon(cx, cy, shapeVerts)) {
                    let noOverlap = true;
                    for (const v of shapeVerts) {
                        const dx = v.x - cx;
                        const dy = v.y - cy;
                        const distSq = dx * dx + dy * dy;
                        if (distSq <= r * r) {
                            noOverlap = false;
                            break;
                        }
                    }
                    if (noOverlap) {
                        // Also verify no edge intersects the circle
                        for (let i = 0; i < shapeVerts.length; i++) {
                            const v1 = shapeVerts[i];
                            const v2 = shapeVerts[(i + 1) % shapeVerts.length];
                            const distToEdge = this.distanceToSegment(cx, cy, v1, v2);
                            if (distToEdge <= r) {
                                noOverlap = false;
                                break;
                            }
                        }
                        if (noOverlap) {
                            return collectData ? { value: 0, triangles: [], sectors: [] } : 0;
                        }
                    }
                }

                // Special case: circle fully inside polygon
                // Exact test: center inside polygon AND all edges farther than radius from center
                if (!isBoundaryMode && triangles.length === 0 && this.pointInPolygon(cx, cy, shapeVerts)) {
                    let circleFullyInside = true;
                    for (let i = 0; i < shapeVerts.length; i++) {
                        const v1 = shapeVerts[i];
                        const v2 = shapeVerts[(i + 1) % shapeVerts.length];
                        const distToEdge = this.distanceToSegment(cx, cy, v1, v2);
                        if (distToEdge <= r) {
                            circleFullyInside = false;
                            break;
                        }
                    }
                    if (circleFullyInside) {
                        const fullArea = Math.PI * r * r;
                        if (collectData) {
                            return { value: fullArea, triangles: [], sectors: [{
                                cx, cy, r, startAngle: 0, endAngle: 2 * Math.PI, value: fullArea,
                                fromEdge: 0, fromParam: 0, toEdge: 0, toParam: 0
                            }] };
                        }
                        return fullArea;
                    }
                }

                // STEP 2: Walk circle arcs and accumulate sector contributions
                // Circular arcs inside the polygon contribute sectors from the circle center
                // This corresponds to integrating along curved boundary segments
                //
                // MATHEMATICAL INSIGHT:
                // For a circular arc from angle Œ∏‚ÇÅ to Œ∏‚ÇÇ at radius r:
                //   - Arc length: s = r¬∑ŒîŒ∏
                //   - Sector area: A = (1/2)r¬≤¬∑ŒîŒ∏
                //
                // The sector formula comes from Green's theorem applied to polar coordinates:
                //   A = (1/2) ‚àÆ (x dy - y dx)
                //     = (1/2) ‚à´[Œ∏‚ÇÅ,Œ∏‚ÇÇ] r¬≤(cos¬≤Œ∏ + sin¬≤Œ∏) dŒ∏
                //     = (1/2) r¬≤ ŒîŒ∏
                //
                // In complex notation: A_sector = (r¬≤/2) Im(log(z‚ÇÇ/z‚ÇÅ)) when |z‚ÇÅ| = |z‚ÇÇ| = r
                if (circlePts.length > 0) {
                    // Deduplicate intersection points by edge/parameter
                    // (multiple edges might intersect circle at same point)
                    const dedupMap = new Map();
                    for (const p of circlePts) {
                        const key = `${p.edgeIndex}:${p.edgeParam.toFixed(8)}`;
                        if (!dedupMap.has(key)) {
                            dedupMap.set(key, {
                                edge: p.edgeIndex,
                                param: p.edgeParam,
                                x: p.x,
                                y: p.y,
                                angle: Math.atan2(p.y - cy, p.x - cx)
                            });
                        }
                    }

                    // Sort intersection points by angle around circle center
                    // This allows us to walk the circle boundary in order
                    const intersections = Array.from(dedupMap.values()).sort((a, b) => a.angle - b.angle);

                    // Walk consecutive pairs of intersection points
                    // Each pair defines a potential arc segment
                    for (let i = 0; i < intersections.length; i++) {
                        const a = intersections[i];
                        const b = intersections[(i + 1) % intersections.length];

                        let start = a.angle;
                        let end = b.angle;
                        let delta = end - start;
                        if (delta <= 0) {
                            delta += 2 * Math.PI;
                            end = start + delta;
                        }

                        // Test if this arc is inside the polygon by checking the midpoint
                        // Winding number interpretation: arc contributes if w(polygon, arc_midpoint) ‚â† 0
                        const mid = start + delta / 2;
                        const midNorm = ((mid % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                        const mx = cx + r * Math.cos(midNorm);
                        const my = cy + r * Math.sin(midNorm);
                        if (!this.pointInPolygon(mx, my, shapeVerts)) continue;

                        // Compute contribution: arc length (boundary mode) or sector area (area mode)
                        const contribution = isBoundaryMode ? r * delta : 0.5 * r * r * delta;
                        measure += contribution;

                        if (collectData) {
                            sectors.push({
                                cx, cy, r,
                                startAngle: start,
                                endAngle: end,
                                value: contribution,
                                fromEdge: a.edge,
                                fromParam: a.param,
                                toEdge: b.edge,
                                toParam: b.param
                            });
                        }
                    }
                } else if (collectData && isBoundaryMode && this.pointInPolygon(cx, cy, shapeVerts)) {
                    // Circle fully inside polygon with no intersections in boundary mode: full circumference.
                    const fullLength = 2 * Math.PI * r;
                    measure = fullLength;
                    sectors.push({
                        cx, cy, r,
                        startAngle: 0,
                        endAngle: 2 * Math.PI,
                        value: fullLength,
                        fromEdge: 0, fromParam: 0, toEdge: 0, toParam: 0
                    });
                } else if (isBoundaryMode && this.pointInPolygon(cx, cy, shapeVerts) && measure === 0) {
                    // Circle fully inside polygon without collectData
                    return 2 * Math.PI * r;
                }

                if (collectData) {
                    return { value: measure, triangles, sectors };
                }
                return measure;
            }

            // Classify the domain for arbitrary shapes
            classifyDomain(cx, cy, R, verts = this.shapeVertices) {
                const centerInside = this.pointInPolygon(cx, cy, verts);

                // Find vertices inside circle
                const verticesInCircle = [];
                for (let i = 0; i < verts.length; i++) {
                    const v = verts[i];
                    const dist = Math.sqrt((v.x - cx) * (v.x - cx) + (v.y - cy) * (v.y - cy));
                    if (dist <= R) {
                        verticesInCircle.push(i);
                    }
                }

                // Find edges that intersect circle
                const edgesIntersecting = [];
                for (let i = 0; i < verts.length; i++) {
                    const v1 = verts[i];
                    const v2 = verts[(i + 1) % verts.length];
                    const p1 = { x: v1.x - cx, y: v1.y - cy };
                    const p2 = { x: v2.x - cx, y: v2.y - cy };
                    const intersections = this.circleSegmentIntersections(p1, p2, R);
                    if (intersections.length > 0) {
                        edgesIntersecting.push(i);
                    }
                }

                // Check if circle is fully inside
                const circleFullyInside = centerInside && edgesIntersecting.length === 0 && verticesInCircle.length === 0;

                // Check if no overlap
                const noOverlap = !centerInside && edgesIntersecting.length === 0 && verticesInCircle.length === 0;

                // Classify domain
                let domain = {
                    type: 'UNKNOWN',
                    centerInside: centerInside,
                    verticesInCircle: verticesInCircle,
                    edgesIntersecting: edgesIntersecting,
                    description: ''
                };

                if (circleFullyInside) {
                    domain.type = 'INTERIOR_FULL';
                    domain.description = 'Circle fully inside shape';
                } else if (noOverlap) {
                    domain.type = 'EXTERIOR_NONE';
                    domain.description = 'No overlap';
                } else if (centerInside) {
                    if (verticesInCircle.length > 0) {
                        domain.type = `INTERIOR_V${verticesInCircle.length}_E${edgesIntersecting.length}`;
                        domain.description = `Center inside, ${verticesInCircle.length} vertex(ces), ${edgesIntersecting.length} edge(s)`;
                    } else {
                        domain.type = `INTERIOR_V0_E${edgesIntersecting.length}`;
                        domain.description = `Center inside, ${edgesIntersecting.length} edge(s) intersecting`;
                    }
                } else {
                    if (verticesInCircle.length > 0) {
                        domain.type = `EXTERIOR_V${verticesInCircle.length}_E${edgesIntersecting.length}`;
                        domain.description = `Center outside, ${verticesInCircle.length} vertex(ces), ${edgesIntersecting.length} edge(s)`;
                    } else if (edgesIntersecting.length > 0) {
                        domain.type = `EXTERIOR_V0_E${edgesIntersecting.length}`;
                        domain.description = `Center outside, ${edgesIntersecting.length} edge(s) intersecting`;
                    }
                }

                return domain;
            }

            // calculateOverlap returns the overlap kernel A(cx, cy):
            // the area of intersection between the shape and a circle centered at (cx, cy).
            // Both the 2D view (dragging) and 3D surface plot just sample this kernel.
            calculateOverlap(cx, cy, R, verts = this.shapeVertices, shapeType = this.shapeType, options = {}) {
                const { collectData = false, recordDebug = true, shapeMeta = null } = options;

                if (recordDebug) {
                    this.debugText = `cx=${cx.toFixed(3)}, cy=${cy.toFixed(3)}, R=${R.toFixed(3)}\n`;
                }

                // Classify domain for all shapes
                const domain = this.classifyDomain(cx, cy, R, verts);
                if (recordDebug) {
                    this.currentCase = domain.type;
                    this.currentDomain = domain;
                    this.debugText += `Domain: ${domain.type}\n`;
                    this.debugText += `Description: ${domain.description}\n`;
                    this.debugText += `Center inside: ${domain.centerInside}\n`;
                    this.debugText += `Vertices in circle: [${domain.verticesInCircle.join(', ')}]\n`;
                    this.debugText += `Edges intersecting: [${domain.edgesIntersecting.join(', ')}]\n`;
                }

                // For square shapes, also compute legacy case classification
                if (shapeType === 'square' && recordDebug) {
                    const ax = Math.abs(cx);
                    const ay = Math.abs(cy);
                    const s = shapeMeta?.squareSize ?? this.squareSize;
                    const dx = Math.max(0, ax - s);
                    const dy = Math.max(0, ay - s);
                    const distToNearestCorner = Math.sqrt((ax - s) * (ax - s) + (ay - s) * (ay - s));
                    const cornerInCircle = distToNearestCorner <= R;
                    const sagitta_x = Math.max(0, ax + R - s);
                    const sagitta_y = Math.max(0, ay + R - s);

                    this.debugText += `\nSquare-specific:\n`;
                    this.debugText += `|cx|=${ax.toFixed(3)}, |cy|=${ay.toFixed(3)}\n`;
                    this.debugText += `dx=${dx.toFixed(3)}, dy=${dy.toFixed(3)}\n`;
                    this.debugText += `distToCorner=${distToNearestCorner.toFixed(3)}, cornerInCircle=${cornerInCircle}\n`;
                    this.debugText += `sagitta_x=${sagitta_x.toFixed(3)}, sagitta_y=${sagitta_y.toFixed(3)}\n`;

                    let caseType = 'H';
                    if (ax + R <= s && ay + R <= s) {
                        caseType = 'A';
                        this.debugText += 'Legacy Case A: Fully inside\n';
                    } else if (dx > 0 && dy > 0 && distToNearestCorner > R) {
                        caseType = 'H';
                        this.debugText += 'Legacy Case H: No overlap\n';
                    } else {
                        const inCornerRegion = sagitta_x > 0 && sagitta_y > 0;
                        if (inCornerRegion) {
                            if (ax < s && ay < s) {
                                caseType = cornerInCircle ? 'D' : 'C';
                                this.debugText += caseType === 'D'
                                    ? 'Legacy Case D: Corner inside circle (center inside square)\n'
                                    : 'Legacy Case C: Center inside, corner outside circle\n';
                            } else if (ax >= s && ay >= s) {
                                if (cornerInCircle) {
                                    caseType = 'D';
                                    this.debugText += 'Legacy Case D: Corner inside circle (center outside both)\n';
                                }
                            } else {
                                if (cornerInCircle) {
                                    caseType = 'D';
                                    this.debugText += 'Legacy Case D: Corner inside circle (mixed position)\n';
                                }
                            }
                        }

                        if (caseType === 'H' && ax < s && ay < s && (sagitta_x > 0 || sagitta_y > 0)) {
                            caseType = 'B';
                            this.debugText += 'Legacy Case B: Center inside, extends beyond edge(s)\n';
                        }

                        if (caseType === 'H' && (ax >= s || ay >= s)) {
                            const dxToEdge = ax >= s ? (ax - s) : 0;
                            const dyToEdge = ay >= s ? (ay - s) : 0;
                            if ((ax >= s && dxToEdge <= R) || (ay >= s && dyToEdge <= R)) {
                                caseType = 'E';
                                this.debugText += 'Legacy Case E: Edge segment (center outside)\n';
                            }
                        }
                    }
                    this.debugText += `Legacy case: ${caseType}\n`;
                }

                return this.overlapByBoundary(cx, cy, R, collectData, verts);
            }

            update3DSurface() {
                if (this.surfaceMesh) {
                    this.scene.remove(this.surfaceMesh);
                }
                if (this.wireframe) {
                    this.scene.remove(this.wireframe);
                }

                const res = this.resolution;
                const range = 4;  // Show region from -2 to 2
                const geometry = new THREE.PlaneGeometry(range, range, res - 1, res - 1);
                const vertices = geometry.attributes.position.array;

                // Remap geometry: X (red) and Z (blue) are inputs, Y (green) is height
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const idx = (i * res + j) * 3;
                        const x = vertices[idx];        // Red axis - input
                        const z = vertices[idx + 1];    // Blue axis - input (read before overwrite)

                        let overlap = 0;
                        for (const poly of this.polygons) {
                            overlap += this.calculateOverlap(
                                x,
                                -z,
                                this.R,
                                poly.vertices,
                                poly.shapeType,
                                { recordDebug: false, shapeMeta: poly }
                            );
                        }

                        const circleMeasure = this.boundaryMode === 'perimeter'
                            ? 2 * Math.PI * this.R
                            : Math.PI * this.R * this.R;

                        // Normalize height to circle measure so it stays in view
                        vertices[idx + 1] = overlap / circleMeasure;  // Green - height (normalized)
                        vertices[idx + 2] = z;                        // Blue - input
                    }
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();

                const material = new THREE.MeshPhongMaterial({
                    color: 0x2196F3,
                    side: THREE.DoubleSide,
                    shininess: 80,
                    opacity: 0.85,
                    transparent: true
                });

                this.surfaceMesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.surfaceMesh);

                const wireframeGeometry = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    opacity: 0.15,
                    transparent: true
                });
                this.wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.scene.add(this.wireframe);
            }

            animate3D() {
                requestAnimationFrame(() => this.animate3D());

                // Update OrbitControls
                if (this.controls) {
                    this.controls.update();
                }

                // Optional: Auto-rotate the surface (disabled by default, controlled by OrbitControls)
                if (this.controls && this.controls.autoRotate) {
                    if (this.surfaceMesh) {
                        this.surfaceMesh.rotation.y += 0.002;
                        this.wireframe.rotation.y += 0.002;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            updateDisplay() {
                this.draw2D();
                this.updateInfo();
            }

            draw2D() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, 600, 600);

                const showGrid = document.getElementById('showGrid').checked;
                const activePoly = this.polygons[this.activePolygonIndex];

                // Grid
                if (showGrid) {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                    for (let i = -2; i <= 2; i += 0.5) {
                        const px = this.worldToPixel(i, 0).x;
                        const py = this.worldToPixel(0, i).y;
                        ctx.beginPath();
                        ctx.moveTo(px, 0);
                        ctx.lineTo(px, 600);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, py);
                        ctx.lineTo(600, py);
                        ctx.stroke();
                    }
                }

                // Axes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                const origin = this.worldToPixel(0, 0);
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, 600);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(600, origin.y);
                ctx.stroke();

                // Draw domain/case regions for active polygon only (before shapes so shapes are on top)
                if (document.getElementById('showRegions').checked && activePoly) {
                    this.shapeType = activePoly.shapeType;
                    this.shapeVertices = activePoly.vertices.map(v => ({ x: v.x, y: v.y }));
                    if (activePoly.shapeType === 'square') {
                        this.squareSize = activePoly.squareSize;
                        this.drawCaseRegions();
                    } else {
                        this.drawDomainRegions();
                    }
                }

                // Draw all polygons
                this.polygons.forEach((poly, idx) => {
                    this.drawPolygonShape(ctx, poly, idx === this.activePolygonIndex);
                });

                // Circle
                const circleCenter = this.worldToPixel(this.cx, this.cy);
                const circleRadius = this.R * this.scale;

                ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(circleCenter.x, circleCenter.y, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Draw overlap region(s)
                this.drawOverlapRegions();

                // Draw animated components if active
                this.drawAnimatedComponents();

                // Draw polygon being drawn
                if (this.isDrawingPolygon && this.polygonVertices.length > 0) {
                    ctx.strokeStyle = '#FF5722';
                    ctx.fillStyle = 'rgba(255, 87, 34, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);

                    ctx.beginPath();
                    const firstPt = this.worldToPixel(this.polygonVertices[0][0], this.polygonVertices[0][1]);
                    ctx.moveTo(firstPt.x, firstPt.y);

                    for (let i = 1; i < this.polygonVertices.length; i++) {
                        const pt = this.worldToPixel(this.polygonVertices[i][0], this.polygonVertices[i][1]);
                        ctx.lineTo(pt.x, pt.y);
                    }

                    // Close preview if we have at least 3 vertices
                    if (this.polygonVertices.length >= 3) {
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw vertices
                    ctx.fillStyle = '#FF5722';
                    for (const vertex of this.polygonVertices) {
                        const pt = this.worldToPixel(vertex[0], vertex[1]);
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }

                // Labels
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px monospace';
                ctx.fillText(`R = ${this.R.toFixed(2)}`, 10, 25);
                ctx.fillText(`Center: (${this.cx.toFixed(2)}, ${this.cy.toFixed(2)})`, 10, 45);
                if (this.isDrawingPolygon) {
                    ctx.fillStyle = '#FF5722';
                    ctx.fillText(`Vertices: ${this.polygonVertices.length}`, 10, 65);
                }
            }

            drawPolygonShape(ctx, poly, isActive) {
                if (!poly || !poly.vertices || poly.vertices.length === 0) return;
                const fill = this.colorWithAlpha(poly.color, 0.18);
                const stroke = poly.color;
                ctx.fillStyle = fill;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = isActive ? 3 : 2;
                ctx.setLineDash(isActive ? [] : [4, 4]);

                ctx.beginPath();
                const firstPixel = this.worldToPixel(poly.vertices[0].x, poly.vertices[0].y);
                ctx.moveTo(firstPixel.x, firstPixel.y);

                for (let i = 1; i < poly.vertices.length; i++) {
                    const pixel = this.worldToPixel(poly.vertices[i].x, poly.vertices[i].y);
                    ctx.lineTo(pixel.x, pixel.y);
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawDomainRegions() {
                const ctx = this.ctx;
                const R = this.R;

                // Dynamic color generation based on vertex and edge counts
                const getDomainColor = (type) => {
                    // Special cases
                    if (type === 'INTERIOR_FULL') return 'rgba(0, 255, 255, 0.15)';  // cyan
                    if (type === 'EXTERIOR_NONE') return 'rgba(200, 200, 200, 0.15)'; // gray
                    if (type === 'UNKNOWN') return 'rgba(255, 0, 255, 0.15)';        // magenta

                    // Parse V and E counts from type string
                    const match = type.match(/(INTERIOR|EXTERIOR)_V(\d+)_E(\d+)/);
                    if (!match) return null;

                    const [_, position, vCount, eCount] = match;
                    const v = parseInt(vCount);
                    const e = parseInt(eCount);

                    // Color scheme:
                    // - Interior: Blue-Green-Yellow spectrum
                    // - Exterior: Red-Orange-Yellow spectrum
                    // - Vertex count affects hue shift
                    // - Edge count affects saturation/brightness

                    if (position === 'INTERIOR') {
                        // Base: Blue (0, 0, 255) -> Green (0, 255, 0) -> Yellow (255, 255, 0)
                        const hueShift = Math.min(v * 60, 180); // 0-180 degrees
                        const edgeBoost = Math.min(e * 30, 120); // Brightness increase

                        let r = Math.min(255, hueShift + edgeBoost);
                        let g = Math.min(255, 100 + hueShift + edgeBoost);
                        let b = Math.max(0, 255 - hueShift - e * 40);

                        return `rgba(${r}, ${g}, ${b}, 0.15)`;
                    } else {
                        // Exterior: Red (255, 0, 0) -> Orange (255, 128, 0) -> Yellow (255, 255, 0)
                        const hueShift = Math.min(v * 50, 200); // Orange shift
                        const edgeBoost = Math.min(e * 30, 120); // Brightness increase

                        let r = 255;
                        let g = Math.min(255, hueShift + edgeBoost);
                        let b = Math.max(0, edgeBoost - 50);

                        return `rgba(${r}, ${g}, ${b}, 0.15)`;
                    }
                };

                // Sample the entire visible space uniformly
                const samples = 120;
                const maxRange = 3;  // Show up to distance 3 from origin in each direction

                for (let i = 0; i < samples; i++) {
                    for (let j = 0; j < samples; j++) {
                        // Map to world coordinates from -maxRange to +maxRange
                        const wx = -maxRange + (i / samples) * (2 * maxRange);
                        const wy = -maxRange + (j / samples) * (2 * maxRange);

                        // Classify domain for this position
                        const domain = this.classifyDomain(wx, wy, R);

                        const color = getDomainColor(domain.type);
                        if (color) {
                            ctx.fillStyle = color;
                            const cellSize = (2 * maxRange) / samples;

                            // Draw this single cell
                            const p1 = this.worldToPixel(wx, wy);
                            const p2 = this.worldToPixel(wx + cellSize, wy + cellSize);
                            const w = Math.abs(p2.x - p1.x);
                            const h = Math.abs(p2.y - p1.y);
                            ctx.fillRect(p1.x, p1.y, w, h);
                        }
                    }
                }

                // Draw circles at vertices to show vertex influence zones
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                for (const v of this.shapeVertices) {
                    const center = this.worldToPixel(v.x, v.y);
                    const radius = R * this.scale;
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Draw labels for domain types
                ctx.font = 'bold 14px monospace';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;

                // Find representative positions for each domain type
                const labelPositions = {
                    'INTERIOR_FULL': [0, 0]
                };

                // Sample to find good label positions
                const labelSamples = 20;
                for (let i = 0; i < labelSamples; i++) {
                    for (let j = 0; j < labelSamples; j++) {
                        const wx = -maxRange + (i / labelSamples) * (2 * maxRange);
                        const wy = -maxRange + (j / labelSamples) * (2 * maxRange);
                        const domain = this.classifyDomain(wx, wy, R);

                        if (!labelPositions[domain.type] && domain.type !== 'INTERIOR_FULL') {
                            labelPositions[domain.type] = [wx, wy];
                        }
                    }
                }

                // Helper function to get label name and color for any domain type
                const getLabelName = (type) => {
                    if (type === 'INTERIOR_FULL') return 'IF';
                    if (type === 'EXTERIOR_NONE') return 'EN';

                    // Parse V#_E# format
                    const match = type.match(/(INTERIOR|EXTERIOR)_V(\d+)_E(\d+)/);
                    if (match) {
                        const [_, position, vCount, eCount] = match;
                        const prefix = position === 'INTERIOR' ? 'I' : 'E';
                        return `${prefix}V${vCount}E${eCount}`;
                    }
                    return type;
                };

                const getLabelColor = (type) => {
                    if (type === 'INTERIOR_FULL') return '#00AAAA';
                    if (type === 'EXTERIOR_NONE') return '#888888';

                    // Parse V#_E# format and generate color matching the region color
                    const match = type.match(/(INTERIOR|EXTERIOR)_V(\d+)_E(\d+)/);
                    if (match) {
                        const [_, position, vCount, eCount] = match;
                        const v = parseInt(vCount);
                        const e = parseInt(eCount);

                        if (position === 'INTERIOR') {
                            const hueShift = Math.min(v * 60, 180);
                            const edgeBoost = Math.min(e * 30, 120);
                            let r = Math.min(255, hueShift + edgeBoost);
                            let g = Math.min(255, 100 + hueShift + edgeBoost);
                            let b = Math.max(0, 255 - hueShift - e * 40);
                            return `rgb(${r}, ${g}, ${b})`;
                        } else {
                            const hueShift = Math.min(v * 50, 200);
                            const edgeBoost = Math.min(e * 30, 120);
                            let r = 255;
                            let g = Math.min(255, hueShift + edgeBoost);
                            let b = Math.max(0, edgeBoost - 50);
                            return `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                    return '#888888';
                };

                for (const [type, pos] of Object.entries(labelPositions)) {
                    if (pos) {
                        const pixel = this.worldToPixel(pos[0], pos[1]);
                        const text = getLabelName(type);

                        // Draw text with white outline
                        ctx.strokeText(text, pixel.x - 10, pixel.y + 6);
                        ctx.fillStyle = getLabelColor(type);
                        ctx.fillText(text, pixel.x - 10, pixel.y + 6);
                    }
                }
            }

            drawCaseRegions() {
                const ctx = this.ctx;
                const R = this.R;
                const s = this.squareSize;

                // Define colors for each case
                const caseColors = {
                    'A': 'rgba(0, 255, 255, 0.15)',      // cyan
                    'B': 'rgba(0, 0, 255, 0.15)',        // blue
                    'C': 'rgba(255, 0, 255, 0.15)',      // magenta
                    'D': 'rgba(255, 255, 0, 0.15)',      // yellow
                    'E': 'rgba(255, 0, 0, 0.15)',        // red
                    'H': 'rgba(200, 200, 200, 0.15)'     // gray
                };

                // Sample the entire visible space uniformly
                const samples = 150;
                const maxRange = 2;  // Show up to distance 2 from origin in each direction

                for (let i = 0; i < samples; i++) {
                    for (let j = 0; j < samples; j++) {
                        // Map to world coordinates from -maxRange to +maxRange
                        const wx = -maxRange + (i / samples) * (2 * maxRange);
                        const wy = -maxRange + (j / samples) * (2 * maxRange);

                        // Determine case for this position (matching calculateOverlap logic)
                        const ax = Math.abs(wx);
                        const ay = Math.abs(wy);
                        const dx = Math.max(0, ax - s);
                        const dy = Math.max(0, ay - s);

                        const distToNearestCorner = Math.sqrt((ax - s) * (ax - s) + (ay - s) * (ay - s));
                        const cornerInCircle = distToNearestCorner <= R;

                        const sagitta_x = Math.max(0, ax + R - s);
                        const sagitta_y = Math.max(0, ay + R - s);

                        let caseType = '';

                        // Circle fully inside
                        if (ax + R <= s && ay + R <= s) {
                            caseType = 'A';
                        } else if (dx > 0 && dy > 0 && distToNearestCorner > R) {
                            // No overlap (too far from corner)
                            caseType = 'H';
                        } else {
                            const inCornerRegion = sagitta_x > 0 && sagitta_y > 0;

                            // Check corner-influenced cases first
                            if (inCornerRegion) {
                                if (ax < s && ay < s) {
                                    caseType = cornerInCircle ? 'D' : 'C';
                                } else if (ax >= s && ay >= s) {
                                    if (cornerInCircle) {
                                        caseType = 'D';
                                    }
                                    // else fall through to E/H check
                                } else {
                                    if (cornerInCircle) {
                                        caseType = 'D';
                                    }
                                    // else fall through to E/H check
                                }
                            }

                            // Case B: center inside, extends beyond edge(s)
                            if (!caseType && ax < s && ay < s && (sagitta_x > 0 || sagitta_y > 0)) {
                                caseType = 'B';
                            }

                            // Case E: center outside, circle reaches edge
                            if (!caseType && (ax >= s || ay >= s)) {
                                const dxToEdge = ax >= s ? (ax - s) : 0;
                                const dyToEdge = ay >= s ? (ay - s) : 0;
                                if ((ax >= s && dxToEdge <= R) || (ay >= s && dyToEdge <= R)) {
                                    caseType = 'E';
                                }
                            }

                            // Case H: no overlap
                            if (!caseType) {
                                caseType = 'H';
                            }
                        }

                        if (caseType && caseColors[caseType]) {
                            ctx.fillStyle = caseColors[caseType];
                            const cellSize = (2 * maxRange) / samples;

                            // Draw this single cell
                            const p1 = this.worldToPixel(wx, wy);
                            const p2 = this.worldToPixel(wx + cellSize, wy + cellSize);
                            const w = Math.abs(p2.x - p1.x);
                            const h = Math.abs(p2.y - p1.y);
                            ctx.fillRect(p1.x, p1.y, w, h);
                        }
                    }
                }

                // Draw labels for each region
                ctx.font = 'bold 16px monospace';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;

                const baseLabels = [
                    { case: 'A', pos: [0, 0], color: '#00CCCC', unique: true },
                    { case: 'B', pos: [0, s - R * 0.5], color: '#0000CC' },
                    { case: 'C', pos: [s - R * 0.8, s - R * 0.8], color: '#CC00CC' },
                    { case: 'D', pos: [s - R * 0.4, s - R * 0.4], color: '#CCCC00' },
                    { case: 'E', pos: [s + R * 0.5, 0], color: '#CC0000' },
                    { case: 'H', pos: [s + R * 0.85, s + R * 0.85], color: '#888888' }
                ];

                // Generate labels with 8-fold symmetry (except A which is unique)
                const labels = [];
                for (const label of baseLabels) {
                    if (label.unique) {
                        labels.push(label);
                    } else {
                        const [x, y] = label.pos;
                        // Add all symmetric positions
                        labels.push({ case: label.case, pos: [x, y], color: label.color });
                        labels.push({ case: label.case, pos: [-x, y], color: label.color });
                        labels.push({ case: label.case, pos: [x, -y], color: label.color });
                        labels.push({ case: label.case, pos: [-x, -y], color: label.color });
                        // Also swap x and y for 8-fold symmetry
                        if (x !== y) {
                            labels.push({ case: label.case, pos: [y, x], color: label.color });
                            labels.push({ case: label.case, pos: [-y, x], color: label.color });
                            labels.push({ case: label.case, pos: [y, -x], color: label.color });
                            labels.push({ case: label.case, pos: [-y, -x], color: label.color });
                        }
                    }
                }

                for (const label of labels) {
                    const pixel = this.worldToPixel(label.pos[0], label.pos[1]);
                    const text = label.case;

                    // Draw text with white outline
                    ctx.strokeText(text, pixel.x - 8, pixel.y + 6);
                    ctx.fillStyle = label.color;
                    ctx.fillText(text, pixel.x - 8, pixel.y + 6);
                }
            }

            drawOverlapRegions() {
                const ctx = this.ctx;
                const circleCenter = this.worldToPixel(this.cx, this.cy);
                const circleRadius = this.R * this.scale;

                const isBoundaryMode = this.boundaryMode === 'perimeter';
                this.polygons.forEach((poly) => {
                    if (!poly || !poly.vertices || poly.vertices.length === 0) return;
                    if (isBoundaryMode) {
                        const data = this.overlapByBoundary(this.cx, this.cy, this.R, true, poly.vertices);
                        if (!data || !data.sectors || data.sectors.length === 0) return;
                        ctx.strokeStyle = poly.color;
                        ctx.lineWidth = 3;
                        data.sectors.forEach((sec) => {
                            ctx.beginPath();
                            ctx.arc(circleCenter.x, circleCenter.y, circleRadius, -sec.startAngle, -sec.endAngle, true);
                            ctx.stroke();
                        });
                    } else {
                        ctx.save();
                        ctx.beginPath();
                        const firstPixel = this.worldToPixel(poly.vertices[0].x, poly.vertices[0].y);
                        ctx.moveTo(firstPixel.x, firstPixel.y);

                        for (let i = 1; i < poly.vertices.length; i++) {
                            const pixel = this.worldToPixel(poly.vertices[i].x, poly.vertices[i].y);
                            ctx.lineTo(pixel.x, pixel.y);
                        }

                        ctx.closePath();
                        ctx.clip();

                        ctx.fillStyle = this.colorWithAlpha(poly.color, 0.35);
                        ctx.strokeStyle = poly.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(circleCenter.x, circleCenter.y, circleRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            updateInfo() {
                document.getElementById('circlePos').textContent =
                    `(${this.cx.toFixed(2)}, ${this.cy.toFixed(2)})`;

                const perPolygon = [];
                for (let i = 0; i < this.polygons.length; i++) {
                    const poly = this.polygons[i];
                    const result = this.calculateOverlap(
                        this.cx,
                        this.cy,
                        this.R,
                        poly.vertices,
                        poly.shapeType,
                        { recordDebug: i === this.activePolygonIndex, shapeMeta: poly }
                    );
                    const value = typeof result === 'number' ? result : (result?.value ?? 0);
                    perPolygon.push({ poly, value });
                }

                const totalOverlap = perPolygon.reduce((acc, item) => acc + item.value, 0);
                const isBoundaryMode = this.boundaryMode === 'perimeter';
                const baseCircleMeasure = isBoundaryMode ? 2 * Math.PI * this.R : Math.PI * this.R * this.R;
                const measureLabel = isBoundaryMode ? 'Length' : 'Area';

                document.getElementById('overlapLabel').textContent = `Total Overlap ${measureLabel}:`;
                document.getElementById('overlapArea').textContent = totalOverlap.toFixed(4);

                document.getElementById('circleMeasureLabel').textContent = isBoundaryMode ? 'Circle Circumference:' : 'Circle Area:';
                document.getElementById('circleArea').textContent = baseCircleMeasure.toFixed(4);

                const percent = (totalOverlap / baseCircleMeasure * 100).toFixed(1);
                document.getElementById('overlapPercentLabel').textContent = isBoundaryMode ? 'Overlap % of circumference:' : 'Overlap %:';
                document.getElementById('overlapPercent').textContent = `${percent}%`;

                this.renderPolygonStats(perPolygon, baseCircleMeasure);

                // Helper to get domain name for display
                const getDomainName = (caseType) => {
                    const baseNames = {
                        'INTERIOR_FULL': '‚¨§ Interior: Circle fully inside shape',
                        'EXTERIOR_NONE': '‚óØ Exterior: No overlap',
                        // Legacy square cases
                        'A': 'Case A: œÄR¬≤ (Circle fully inside)',
                        'B': 'Case B: œÄR¬≤ - segment (Extends beyond one edge)',
                        'C': 'Case C: œÄR¬≤ - 2 segments (Extends beyond two edges)',
                        'D': 'Case D: Corner sector (Corner inside circle)',
                        'E': 'Case E: Single segment (Mostly outside, edge)',
                        'H': 'Case H: 0 (No overlap)'
                    };

                    if (baseNames[caseType]) return baseNames[caseType];

                    // Parse V#_E# format
                    const match = caseType.match(/(INTERIOR|EXTERIOR)_V(\d+)_E(\d+)/);
                    if (match) {
                        const [_, position, vCount, eCount] = match;
                        const symbol = position === 'INTERIOR' ? '‚¨§' : '‚óØ';
                        const posName = position === 'INTERIOR' ? 'Interior' : 'Exterior';
                        return `${symbol} ${posName}: ${vCount} vertex(ces), ${eCount} edge(s)`;
                    }

                    return `Domain: ${caseType}`;
                };

                document.getElementById('caseIndicator').textContent = getDomainName(this.currentCase);

                document.getElementById('debugInfo').textContent = this.debugText;
            }

            renderPolygonStats(stats, baseCircleMeasure) {
                const container = document.getElementById('polygonStatsContainer');
                const grid = document.getElementById('polygonStats');
                if (!container || !grid) return;

                if (!stats || stats.length === 0) {
                    container.style.display = 'none';
                    grid.innerHTML = '';
                    return;
                }

                container.style.display = 'block';
                grid.innerHTML = '';
                const isBoundaryMode = this.boundaryMode === 'perimeter';
                const metricName = isBoundaryMode ? 'length' : 'area';

                stats.forEach(({ poly, value }) => {
                    const card = document.createElement('div');
                    card.className = 'polygon-stat-card';

                    const header = document.createElement('div');
                    header.className = 'polygon-stat-header';

                    const dot = document.createElement('span');
                    dot.className = 'color-dot';
                    dot.style.background = poly.color;

                    const title = document.createElement('span');
                    title.textContent = `${poly.name} (${poly.shapeType})`;

                    header.appendChild(dot);
                    header.appendChild(title);

                    const valueLine = document.createElement('div');
                    valueLine.textContent = `Overlap ${metricName}: ${value.toFixed(4)}`;

                    const percentLine = document.createElement('div');
                    const percent = (value / baseCircleMeasure * 100).toFixed(1);
                    percentLine.textContent = `Share of circle: ${percent}%`;

                    card.appendChild(header);
                    card.appendChild(valueLine);
                    card.appendChild(percentLine);
                    grid.appendChild(card);
                });
            }

            // ===== ANIMATION METHODS =====

            /**
             * Step 1: Prepare boundary elements from overlap calculation
             * Returns elements with normalized point representations
             */
            prepareBoundaryElements(triangles, sectors) {
                const elements = [];
                const numEdges = this.shapeVertices.length;

                // Helper: Create a unique key for a point on the polygon boundary
                // Normalize vertices so edge i at t=1.0 becomes edge i+1 at t=0.0
                const pointKey = (edgeIdx, param) => {
                    // If at end of edge (t ‚âà 1.0), normalize to start of next edge
                    if (Math.abs(param - 1.0) < 1e-6) {
                        const nextEdge = (edgeIdx + 1) % numEdges;
                        return `${nextEdge}:0.00000000`;
                    }
                    return `${edgeIdx}:${param.toFixed(8)}`;
                };

                // Add triangles
                for (const tri of triangles) {
                    const triValue = tri.value !== undefined ? tri.value : tri.area;
                    elements.push({
                        type: 'triangle',
                        data: tri,
                        startPoint: pointKey(tri.edgeIndex, tri.edgeParam),
                        endPoint: pointKey(tri.edgeIndex, tri.edgeParamEnd),
                        metric: triValue
                    });
                }

                // Add sectors
                for (const sec of sectors) {
                    const secValue = sec.value !== undefined ? sec.value : sec.area;
                    elements.push({
                        type: 'sector',
                        data: sec,
                        startPoint: pointKey(sec.fromEdge, sec.fromParam),
                        endPoint: pointKey(sec.toEdge, sec.toParam),
                        metric: secValue
                    });
                }

                return elements;
            }

            /**
             * Step 2: Find connected components in the boundary graph
             * Returns array of component groups
             */
            findConnectedComponents(elements) {
                if (elements.length === 0) return [];

                // Build adjacency map: point -> elements that touch it
                const pointToElements = new Map();

                elements.forEach((elem, idx) => {
                    if (!pointToElements.has(elem.startPoint)) {
                        pointToElements.set(elem.startPoint, []);
                    }
                    pointToElements.get(elem.startPoint).push(idx);

                    if (!pointToElements.has(elem.endPoint)) {
                        pointToElements.set(elem.endPoint, []);
                    }
                    pointToElements.get(elem.endPoint).push(idx);
                });

                // Find connected components using BFS
                const visited = new Set();
                const components = [];

                for (let startIdx = 0; startIdx < elements.length; startIdx++) {
                    if (visited.has(startIdx)) continue;

                    // Start new component
                    const component = [];
                    const queue = [startIdx];

                    while (queue.length > 0) {
                        const idx = queue.shift();
                        if (visited.has(idx)) continue;

                        visited.add(idx);
                        component.push(idx);

                        // Find neighbors (elements sharing endpoints)
                        const elem = elements[idx];
                        const neighbors = [
                            ...(pointToElements.get(elem.startPoint) || []),
                            ...(pointToElements.get(elem.endPoint) || [])
                        ];

                        for (const neighborIdx of neighbors) {
                            if (!visited.has(neighborIdx)) {
                                queue.push(neighborIdx);
                            }
                        }
                    }

                    if (component.length > 0) {
                        components.push(component);
                    }
                }

                return components;
            }

            /**
             * Step 3: Order elements within a component to trace around the boundary
             * Returns ordered list of element indices
             */
            orderComponentBoundary(componentIndices, elements) {
                if (componentIndices.length === 0) return [];
                if (componentIndices.length === 1) return componentIndices;

                // Build a map: startPoint -> array of element indices
                const startPointMap = new Map();

                for (const idx of componentIndices) {
                    const elem = elements[idx];
                    if (!startPointMap.has(elem.startPoint)) {
                        startPointMap.set(elem.startPoint, []);
                    }
                    startPointMap.get(elem.startPoint).push(idx);
                }

                // Helper: Extract edge index from point key (format "edge:param")
                const getEdgeFromPoint = (pointKey) => {
                    return parseInt(pointKey.split(':')[0]);
                };

                // Trace the boundary starting from the first element
                const ordered = [];
                const used = new Set();
                let currentIdx = componentIndices[0];

                while (ordered.length < componentIndices.length) {
                    if (used.has(currentIdx)) break;

                    ordered.push(currentIdx);
                    used.add(currentIdx);

                    // Find next element: one that starts where current ends
                    const currentEnd = elements[currentIdx].endPoint;
                    const currentEndEdge = getEdgeFromPoint(currentEnd);
                    const candidates = (startPointMap.get(currentEnd) || []).filter(idx => !used.has(idx));

                    if (candidates.length === 0) {
                        // Can't continue, try to find any unused element
                        const remaining = componentIndices.find(idx => !used.has(idx));
                        if (remaining !== undefined) {
                            currentIdx = remaining;
                        } else {
                            break;
                        }
                    } else if (candidates.length === 1) {
                        currentIdx = candidates[0];
                    } else {
                        // Multiple candidates - check for immediate loops (detours)
                        // An immediate loop is a path that returns to currentEnd
                        const immediateLoops = [];

                        for (const candIdx of candidates) {
                            // Check if this candidate leads back to currentEnd
                            let checkIdx = candIdx;
                            let loopLength = 0;
                            const visited = new Set([currentIdx]);

                            while (loopLength < 10) { // Max loop depth to avoid infinite loops
                                if (used.has(checkIdx)) break;

                                visited.add(checkIdx);
                                const endPt = elements[checkIdx].endPoint;

                                if (endPt === currentEnd) {
                                    // Found a loop back to currentEnd!
                                    immediateLoops.push({ startIdx: candIdx, length: loopLength + 1 });
                                    break;
                                }

                                // Try to continue the path
                                const nextCandidates = (startPointMap.get(endPt) || [])
                                    .filter(idx => !used.has(idx) && !visited.has(idx));

                                if (nextCandidates.length === 0) break;
                                checkIdx = nextCandidates[0];
                                loopLength++;
                            }
                        }

                        if (immediateLoops.length > 0) {
                            // Prefer shortest immediate loop
                            immediateLoops.sort((a, b) => a.length - b.length);
                            currentIdx = immediateLoops[0].startIdx;
                        } else {
                            // No immediate loops - prefer triangle on same edge over sectors
                            const trianglesOnSameEdge = candidates.filter(idx => {
                                const elem = elements[idx];
                                return elem.type === 'triangle' && getEdgeFromPoint(elem.startPoint) === currentEndEdge;
                            });

                            if (trianglesOnSameEdge.length > 0) {
                                currentIdx = trianglesOnSameEdge[0];
                            } else {
                                // No triangles on same edge, just take first candidate
                                currentIdx = candidates[0];
                            }
                        }
                    }
                }

                return ordered;
            }

            /**
             * Main animation starter
             */
            startAnimation() {
                // Get overlap data
                const result = this.overlapByBoundary(this.cx, this.cy, this.R, true);

                if (!result.triangles && !result.sectors) {
                    alert('No overlap to animate');
                    return;
                }

                // Step 1: Prepare boundary elements
                const elements = this.prepareBoundaryElements(
                    result.triangles || [],
                    result.sectors || []
                );

                if (elements.length === 0) {
                    alert('No overlap elements found');
                    return;
                }

                // DEBUG OUTPUT
                console.log('\n========== ANIMATION DEBUG ==========');
                console.log(`Circle: cx=${this.cx.toFixed(3)}, cy=${this.cy.toFixed(3)}, R=${this.R.toFixed(3)}`);
                console.log(`\n--- ALL ELEMENTS (${elements.length}) ---`);
                elements.forEach((elem, idx) => {
                    const type = elem.type.charAt(0).toUpperCase();
                    const measureVal = (elem.metric !== undefined ? elem.metric : (elem.data.value ?? elem.data.area ?? 0)).toFixed(4);
                    console.log(`[${idx}] ${type} | start: ${elem.startPoint} | end: ${elem.endPoint} | value: ${measureVal}`);
                });

                // Step 2: Find connected components
                const componentGroups = this.findConnectedComponents(elements);

                console.log(`\n--- CONNECTED COMPONENTS (${componentGroups.length}) ---`);
                componentGroups.forEach((group, compIdx) => {
                    console.log(`Component ${compIdx}: ${group.length} elements`);
                    console.log(`  Indices: [${group.join(', ')}]`);
                });

                // Step 3: Order each component and flatten into animation sequence
                const animationSequence = [];

                console.log('\n--- ORDERING WITHIN COMPONENTS ---');
                for (let compIdx = 0; compIdx < componentGroups.length; compIdx++) {
                    const componentIndices = componentGroups[compIdx];
                    const orderedIndices = this.orderComponentBoundary(componentIndices, elements);

                    console.log(`\nComponent ${compIdx}:`);
                    console.log(`  Original: [${componentIndices.join(', ')}]`);
                    console.log(`  Ordered:  [${orderedIndices.join(', ')}]`);

                    // Show the trace
                    console.log('  Trace:');
                    orderedIndices.forEach((idx, pos) => {
                        const elem = elements[idx];
                        const type = elem.type.charAt(0).toUpperCase();
                        console.log(`    ${pos}. [${idx}] ${type} ${elem.startPoint} -> ${elem.endPoint}`);
                    });

                    // Show geometric endpoints to verify continuity
                    console.log('  Geometric Trace (boundary endpoints):');
                    orderedIndices.forEach((idx, pos) => {
                        const elem = elements[idx];
                        const data = elem.data;

                        if (elem.type === 'triangle') {
                            // For triangles: p2 and p3 are the boundary edge endpoints
                            const p2 = `(${data.p2.x.toFixed(3)}, ${data.p2.y.toFixed(3)})`;
                            const p3 = `(${data.p3.x.toFixed(3)}, ${data.p3.y.toFixed(3)})`;
                            console.log(`    ${pos}. T: ${p2} ‚Üí ${p3}`);
                        } else {
                            // For sectors: compute arc endpoints
                            const startX = data.cx + data.r * Math.cos(data.startAngle);
                            const startY = data.cy + data.r * Math.sin(data.startAngle);
                            const endX = data.cx + data.r * Math.cos(data.endAngle);
                            const endY = data.cy + data.r * Math.sin(data.endAngle);
                            const start = `(${startX.toFixed(3)}, ${startY.toFixed(3)})`;
                            const end = `(${endX.toFixed(3)}, ${endY.toFixed(3)})`;
                            console.log(`    ${pos}. S: ${start} ‚Üí ${end}`);
                        }
                    });

                    // Add elements from this component to the sequence
                    for (const idx of orderedIndices) {
                        animationSequence.push(elements[idx]);
                    }
                }

                console.log(`\n--- FINAL ANIMATION SEQUENCE (${animationSequence.length}) ---`);
                animationSequence.forEach((elem, pos) => {
                    const type = elem.type.charAt(0).toUpperCase();
                    const measureVal = (elem.metric !== undefined ? elem.metric : (elem.data.value ?? elem.data.area ?? 0)).toFixed(4);
                    console.log(`${pos}. ${type} | ${elem.startPoint} -> ${elem.endPoint} | value: ${measureVal}`);
                });
                console.log('=====================================\n');

                // Store animation data
                this.animationComponents = animationSequence;
                this.animationStep = 0;
                this.isAnimating = true;

                // Update UI
                document.getElementById('animateBtn').textContent = '‚è∏Ô∏è Stop Animation';
                document.getElementById('animationStatus').style.display = 'inline';

                // Start animation loop
                this.animateNextFrame();
            }

            /**
             * Stop animation
             */
            stopAnimation() {
                this.isAnimating = false;
                this.animationStep = 0;
                this.animationComponents = [];

                if (this.animationTimerId) {
                    clearTimeout(this.animationTimerId);
                    this.animationTimerId = null;
                }

                // Update UI
                document.getElementById('animateBtn').textContent = '‚ñ∂Ô∏è Animate Overlap Calculation';
                document.getElementById('animationStatus').style.display = 'none';

                // Redraw
                this.updateDisplay();
            }

            /**
             * Animation frame update
             */
            animateNextFrame() {
                if (!this.isAnimating) return;

                this.updateDisplay();
                this.animationStep++;

                if (this.animationStep > this.animationComponents.length) {
                    this.animationStep = 0; // Loop
                }

                this.animationTimerId = setTimeout(() => this.animateNextFrame(), 800);
            }

            /**
             * Draw animated components on the canvas
             *
             * VISUALIZATION STRATEGY:
             * Shows progressive accumulation of overlap area:
             * 1. Cumulative region (all previous components) - shown in muted color
             * 2. Current component being added - shown highlighted and overlaid
             * 3. Running total is displayed numerically
             *
             * Sectors are approximated as polygons for cumulative rendering since
             * the partial sums are not necessarily clean sectors or triangles.
             */
            drawAnimatedComponents() {
                if (!this.isAnimating || this.animationComponents.length === 0) return;

                const ctx = this.ctx;
                let triangleCount = 0;
                let sectorCount = 0;
                let cumulativeArea = 0;

                // STEP 1: Draw cumulative region (all components up to but NOT including current)
                if (this.animationStep > 1) {
                    this.drawCumulativeRegion(ctx, this.animationStep - 1);

                    // Calculate cumulative area
                    for (let i = 0; i < this.animationStep - 1; i++) {
                        const component = this.animationComponents[i];
                        const value = component.data.value !== undefined ?
                                    component.data.value :
                                    (component.data.area || 0);
                        cumulativeArea += value;
                    }
                }

                // STEP 2: Draw current component being added (highlighted)
                if (this.animationStep > 0 && this.animationStep <= this.animationComponents.length) {
                    const currentIdx = this.animationStep - 1;
                    const component = this.animationComponents[currentIdx];

                    if (component.type === 'triangle') {
                        triangleCount = this.animationComponents.slice(0, this.animationStep)
                                           .filter(c => c.type === 'triangle').length;
                        this.drawAnimatedTriangle(ctx, component.data, true, triangleCount);
                    } else if (component.type === 'sector') {
                        sectorCount = this.animationComponents.slice(0, this.animationStep)
                                         .filter(c => c.type === 'sector').length;
                        this.drawAnimatedSector(ctx, component.data, true, sectorCount);
                    }
                }

                // Draw progress info with running total
                this.drawAnimationProgress(ctx, triangleCount, sectorCount, cumulativeArea);
            }

            /**
             * Convert a component (triangle or sector) to polygon vertices in world coords
             */
            componentToPolygon(component) {
                if (component.type === 'triangle') {
                    const tri = component.data;
                    return [
                        { x: tri.p1.x, y: tri.p1.y },
                        { x: tri.p2.x, y: tri.p2.y },
                        { x: tri.p3.x, y: tri.p3.y }
                    ];
                } else if (component.type === 'sector') {
                    const sec = component.data;
                    const segments = 32;
                    const angleRange = sec.endAngle - sec.startAngle;
                    const angleStep = angleRange / segments;

                    const vertices = [{ x: sec.cx, y: sec.cy }];
                    for (let j = 0; j <= segments; j++) {
                        const angle = sec.startAngle + j * angleStep;
                        vertices.push({
                            x: sec.cx + sec.r * Math.cos(angle),
                            y: sec.cy + sec.r * Math.sin(angle)
                        });
                    }
                    return vertices;
                }
                return [];
            }

            /**
             * Test if point (px, py) is inside a convex polygon using cross-product method
             */
            pointInConvexPoly(px, py, vertices) {
                if (vertices.length < 3) return false;
                let sign = null;
                for (let i = 0; i < vertices.length; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % vertices.length];
                    const cross = (v2.x - v1.x) * (py - v1.y) - (v2.y - v1.y) * (px - v1.x);
                    if (Math.abs(cross) < 1e-12) continue;
                    const s = cross > 0;
                    if (sign === null) sign = s;
                    else if (sign !== s) return false;
                }
                return true;
            }

            /**
             * Sutherland-Hodgman algorithm: clip a polygon against a half-plane defined by edge (e1, e2)
             * Returns vertices of the clipped polygon (on the left side of e1‚Üíe2)
             */
            clipPolygonByEdge(polygon, e1, e2) {
                if (polygon.length < 3) return [];

                const output = [];
                const n = polygon.length;

                // Edge vector and normal
                const edgeX = e2.x - e1.x;
                const edgeY = e2.y - e1.y;

                // Check which side of edge a point is on (positive = left/inside)
                const side = (p) => edgeX * (p.y - e1.y) - edgeY * (p.x - e1.x);

                // Line intersection
                const intersect = (p1, p2) => {
                    const d1 = side(p1);
                    const d2 = side(p2);
                    const t = d1 / (d1 - d2);
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                };

                for (let i = 0; i < n; i++) {
                    const curr = polygon[i];
                    const next = polygon[(i + 1) % n];
                    const currSide = side(curr);
                    const nextSide = side(next);

                    if (currSide >= 0) {
                        // Current vertex is inside
                        output.push(curr);
                        if (nextSide < 0) {
                            // Next is outside, add intersection
                            output.push(intersect(curr, next));
                        }
                    } else if (nextSide >= 0) {
                        // Current is outside, next is inside, add intersection
                        output.push(intersect(curr, next));
                    }
                }

                return output;
            }

            /**
             * Clip polygon A by convex polygon B (compute A ‚à© B)
             * Returns the intersection polygon vertices
             */
            clipConvexPolygons(polyA, polyB) {
                if (polyA.length < 3 || polyB.length < 3) return [];

                let result = [...polyA];

                for (let i = 0; i < polyB.length; i++) {
                    if (result.length < 3) return [];
                    const e1 = polyB[i];
                    const e2 = polyB[(i + 1) % polyB.length];
                    result = this.clipPolygonByEdge(result, e1, e2);
                }

                return result;
            }

            /**
             * Compute signed area of a polygon (positive = CCW, negative = CW)
             */
            polygonArea(vertices) {
                if (vertices.length < 3) return 0;
                let area = 0;
                for (let i = 0; i < vertices.length; i++) {
                    const j = (i + 1) % vertices.length;
                    area += vertices[i].x * vertices[j].y;
                    area -= vertices[j].x * vertices[i].y;
                }
                return area / 2;
            }

            /**
             * Subtract convex polygon B from convex polygon A
             * Returns an array of polygons representing A - B
             * Note: Result may be non-convex, returned as triangulated pieces
             */
            subtractConvexPolygons(polyA, polyB) {
                if (polyA.length < 3) return [];
                if (polyB.length < 3) return [polyA];

                // Compute intersection
                const intersection = this.clipConvexPolygons(polyA, polyB);

                // If no intersection, A is unchanged
                if (intersection.length < 3) return [polyA];

                // If intersection equals A (within tolerance), A is fully inside B
                const areaA = Math.abs(this.polygonArea(polyA));
                const areaInt = Math.abs(this.polygonArea(intersection));
                if (Math.abs(areaA - areaInt) < 1e-10) return [];

                // Otherwise, we need to compute A - intersection
                // For simplicity, triangulate the difference using ear clipping on the boundary
                // This is complex; use a simpler approach: return the original minus intersection area
                // by returning both polygons with opposite winding for rendering

                // Simple approach: return A with a "hole" represented as reversed intersection
                // This works with canvas evenodd fill rule
                return [{ outer: polyA, hole: intersection }];
            }

            /**
             * Compute net winding regions from positive and negative polygon sets.
             * Returns { positive: [...polygons], negative: [...polygons] }
             * where each array contains polygons with their net winding after cancellation.
             */
            computeNetWindingRegions(positivePolys, negativePolys) {
                // For each positive polygon, subtract all negative polygons that intersect it
                // For each negative polygon, subtract all positive polygons that intersect it

                const netPositive = [];
                const netNegative = [];

                // Process positive polygons
                for (const posPoly of positivePolys) {
                    let remaining = [posPoly];

                    for (const negPoly of negativePolys) {
                        const newRemaining = [];
                        for (const poly of remaining) {
                            const intersection = this.clipConvexPolygons(poly, negPoly);
                            if (intersection.length < 3) {
                                // No intersection, poly unchanged
                                newRemaining.push(poly);
                            } else {
                                // Has intersection - mark as having a hole
                                newRemaining.push({ outer: poly, hole: intersection });
                            }
                        }
                        remaining = newRemaining;
                    }
                    netPositive.push(...remaining);
                }

                // Process negative polygons
                for (const negPoly of negativePolys) {
                    let remaining = [negPoly];

                    for (const posPoly of positivePolys) {
                        const newRemaining = [];
                        for (const poly of remaining) {
                            const actualPoly = poly.outer || poly;
                            const intersection = this.clipConvexPolygons(actualPoly, posPoly);
                            if (intersection.length < 3) {
                                newRemaining.push(poly);
                            } else {
                                newRemaining.push({ outer: actualPoly, hole: intersection });
                            }
                        }
                        remaining = newRemaining;
                    }
                    netNegative.push(...remaining);
                }

                return { positive: netPositive, negative: netNegative };
            }

            /**
             * Draw the cumulative region showing net winding number.
             *
             * Computes actual net winding at each pixel by counting how many
             * +1 shapes contain it minus how many -1 shapes contain it.
             * Colors by net winding: positive = blue, negative = red, zero = transparent.
             * Intensity increases with |winding|.
             */
            drawCumulativeRegion(ctx, upToStep) {
                if (upToStep <= 0) return;

                // Collect all polygons with their winding contribution
                const polys = [];
                for (let i = 0; i < upToStep && i < this.animationComponents.length; i++) {
                    const component = this.animationComponents[i];
                    const value = component.data.value !== undefined
                        ? component.data.value
                        : (component.data.area || 0);
                    const vertices = this.componentToPolygon(component);
                    if (vertices.length < 3) continue;

                    // Convert to pixel coordinates
                    const pixelVerts = vertices.map(v => this.worldToPixel(v.x, v.y));
                    polys.push({
                        vertices: pixelVerts,
                        winding: value >= 0 ? 1 : -1
                    });
                }

                if (polys.length === 0) return;

                // Compute bounding box in pixel coordinates
                let minPx = Infinity, maxPx = -Infinity, minPy = Infinity, maxPy = -Infinity;
                for (const poly of polys) {
                    for (const v of poly.vertices) {
                        minPx = Math.min(minPx, v.x);
                        maxPx = Math.max(maxPx, v.x);
                        minPy = Math.min(minPy, v.y);
                        maxPy = Math.max(maxPy, v.y);
                    }
                }

                // Add margin and clamp to canvas
                minPx = Math.max(0, Math.floor(minPx) - 2);
                maxPx = Math.min(this.canvas2d.width, Math.ceil(maxPx) + 2);
                minPy = Math.max(0, Math.floor(minPy) - 2);
                maxPy = Math.min(this.canvas2d.height, Math.ceil(maxPy) + 2);

                const width = maxPx - minPx;
                const height = maxPy - minPy;
                if (width <= 0 || height <= 0) return;

                // Create offscreen canvas for compositing
                const offscreen = document.createElement('canvas');
                offscreen.width = width;
                offscreen.height = height;
                const offCtx = offscreen.getContext('2d');
                const imageData = offCtx.createImageData(width, height);
                const data = imageData.data;

                // Point-in-polygon test (works for convex and concave)
                const pointInPoly = (px, py, verts) => {
                    let inside = false;
                    for (let i = 0, j = verts.length - 1; i < verts.length; j = i++) {
                        const xi = verts[i].x, yi = verts[i].y;
                        const xj = verts[j].x, yj = verts[j].y;
                        if (((yi > py) !== (yj > py)) &&
                            (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                };

                // For each pixel, compute net winding
                for (let py = 0; py < height; py++) {
                    const canvasY = minPy + py;
                    for (let px = 0; px < width; px++) {
                        const canvasX = minPx + px;
                        let netWinding = 0;

                        for (const poly of polys) {
                            if (pointInPoly(canvasX + 0.5, canvasY + 0.5, poly.vertices)) {
                                netWinding += poly.winding;
                            }
                        }

                        if (netWinding !== 0) {
                            const idx = (py * width + px) * 4;
                            const intensity = Math.min(Math.abs(netWinding), 3);
                            const alpha = Math.floor(60 + 50 * intensity); // 60-210

                            if (netWinding > 0) {
                                // Blue for positive
                                data[idx] = 0;
                                data[idx + 1] = Math.floor(80 + 20 * intensity);
                                data[idx + 2] = 255;
                            } else {
                                // Red for negative
                                data[idx] = 255;
                                data[idx + 1] = Math.floor(40 + 10 * intensity);
                                data[idx + 2] = 0;
                            }
                            data[idx + 3] = alpha;
                        }
                    }
                }

                // Put image data on offscreen canvas, then composite onto main canvas
                offCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(offscreen, minPx, minPy);
            }

            /**
             * Draw a single animated triangle
             */
            drawAnimatedTriangle(ctx, tri, isCurrent, index) {
                const p1 = this.worldToPixel(tri.p1.x, tri.p1.y);
                const p2 = this.worldToPixel(tri.p2.x, tri.p2.y);
                const p3 = this.worldToPixel(tri.p3.x, tri.p3.y);

                // Color by sign of area: positive = blue, negative = red
                const value = tri.value !== undefined ? tri.value : tri.area;
                const isPositive = value >= 0;
                const baseColor = isPositive ? '0, 128, 255' : '255, 64, 0';
                const highlightColor = isPositive ? '#0080FF' : '#FF4000';

                ctx.fillStyle = isCurrent ? `rgba(${baseColor}, 0.7)` : `rgba(${baseColor}, 0.4)`;
                ctx.strokeStyle = isCurrent ? highlightColor : `rgba(${baseColor}, 0.6)`;
                ctx.lineWidth = isCurrent ? 3 : 2;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                if (isCurrent) {
                    const centerX = (p1.x + p2.x + p3.x) / 3;
                    const centerY = (p1.y + p2.y + p3.y) / 3;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 14px monospace';
                    const label = `T${index}: ${value.toFixed(4)}`;
                    ctx.strokeText(label, centerX - 40, centerY);
                    ctx.fillText(label, centerX - 40, centerY);
                }
            }

            /**
             * Draw a single animated sector
             */
            drawAnimatedSector(ctx, sec, isCurrent, index) {
                const center = this.worldToPixel(sec.cx, sec.cy);
                const radius = sec.r * this.scale;

                // Color by sign of area: positive = blue, negative = red
                const value = sec.value !== undefined ? sec.value : sec.area;
                const isPositive = value >= 0;
                const baseColor = isPositive ? '0, 128, 255' : '255, 64, 0';
                const highlightColor = isPositive ? '#0080FF' : '#FF4000';

                ctx.fillStyle = isCurrent ? `rgba(${baseColor}, 0.7)` : `rgba(${baseColor}, 0.4)`;
                ctx.strokeStyle = isCurrent ? highlightColor : `rgba(${baseColor}, 0.6)`;
                ctx.lineWidth = isCurrent ? 3 : 2;

                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.arc(center.x, center.y, radius, -sec.startAngle, -sec.endAngle, true);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                if (isCurrent) {
                    const midAngle = (sec.startAngle + sec.endAngle) / 2;
                    const labelRadius = radius * 0.6;
                    const labelX = center.x + labelRadius * Math.cos(midAngle);
                    const labelY = center.y - labelRadius * Math.sin(midAngle);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    ctx.font = 'bold 14px monospace';
                    const label = `S${index}: ${value.toFixed(4)}`;
                    ctx.strokeText(label, labelX - 40, labelY);
                    ctx.fillText(label, labelX - 40, labelY);
                }
            }

            /**
             * Draw animation progress information
             * Shows step number, component counts, and running total area
             */
            drawAnimationProgress(ctx, triangleCount, sectorCount, cumulativeArea) {
                const totalTriangles = this.animationComponents.filter(c => c.type === 'triangle').length;
                const totalSectors = this.animationComponents.filter(c => c.type === 'sector').length;

                ctx.fillStyle = '#FF9800';
                ctx.font = 'bold 16px monospace';

                if (this.animationStep > 0 && this.animationStep <= this.animationComponents.length) {
                    ctx.fillText(`Step ${this.animationStep} / ${this.animationComponents.length}`, 10, 85);
                    ctx.fillText(`Triangles: ${triangleCount}/${totalTriangles}, Sectors: ${sectorCount}/${totalSectors}`, 10, 105);

                    // Show cumulative area + current component value
                    const currentComponent = this.animationComponents[this.animationStep - 1];
                    const currentValue = currentComponent.data.value !== undefined ?
                                       currentComponent.data.value :
                                       (currentComponent.data.area || 0);
                    const totalSoFar = cumulativeArea + currentValue;

                    ctx.fillStyle = '#4CAF50';  // Green for cumulative
                    ctx.fillText(`Previous sum: ${cumulativeArea.toFixed(5)}`, 10, 125);
                    ctx.fillStyle = currentValue >= 0 ? '#0080FF' : '#FF4000';  // Blue/red for current
                    ctx.fillText(`Adding: ${currentValue >= 0 ? '+' : ''}${currentValue.toFixed(5)}`, 10, 145);
                    ctx.fillStyle = '#9C27B0';  // Purple for total
                    ctx.fillText(`New total: ${totalSoFar.toFixed(5)}`, 10, 165);
                }
            }

        }

        window.addEventListener('load', () => {
            new CircleSquareOverlap();
        });
    </script>
</body>
</html>
